<!DOCTYPE html>
<html lang="en">

<head>
	<title>threejs webgl - materials - transparency</title>
	<style>
		body {
			color: #000;
			background-color: #fff;
			margin-left: 240px;
			margin-right: 240px;

		}

		body {
			font-family: 'Libre Baskerville', sans-serif;
		}

		h1,
		h2,
		h3,
		h4 {
			font-family: 'Libre Baskerville', sans-serif;
		}

		table.blueTable {
			//border: 1px solid #1C6EA4;
			background-color: #EEEEEE;
			text-align: left;
			border-collapse: collapse;
			display: inline-block;
			float: left;
			padding: 10px;
			font-size: 8px;
		}

		table.blueTable td,
		table.blueTable th {
			border: 1px solid #AAAAAA;
			padding: 3px 2px;
		}

		table.blueTable tbody td {
			font-size: 8px;
		}

		table.blueTable tr:nth-child(even) {
			background: #D0E4F5;
		}

		table.blueTable thead {
			background: rgb(231, 243, 253);
		}

		table.blueTable thead th {
			font-size: 10px;
		}
	</style>
	<link href="https://fonts.googleapis.com/css?family=Libre+Baskerville|Open+Sans" rel="stylesheet">
</head>

<body>

	<h1>Todd Coxeter</h1>

			<form>
				<input type="text" value="RBRBRB" name="rules">
			</form>

			<div id="tables">
				Debug
			</div>

			<script>
				'use strict';
				var input = "RBRBRB";

				var debug = false;

				function Table(name, genList) {
					this.name = name;
					this.genList = genList;
					this.rows = [];
					this.rowCosets = [];
					this.firstEmpty = [];
					this.lastEmpty = [];
					this.rowForCoset = new Map();
					this.firstNonClosed = 0;
				}

				Table.prototype = {
					constructor: Relations,

					toHTML: function (symbolMapper) {
						var s = "<table class='blueTable'><thead><th>" + this.name + "</th>";
						for (var i = 0; i < this.genList.length; i++) {
							s += "<th>" + symbolMapper(this.genList[i]) + "</th>";
						}
						s += "</thead>";
						for (var i = 0; i < this.rows.length; i++) {
							s += "<tr><td>" + this.rowCosets[i] + "</td>";
							for (var j = 0; j < this.genList.length; j++) {
								var o = this.rows[i][j];
								s += "<td>" + (o == undefined ? "" : o) + "</td>";
							}
							s += "</tr>";
						}
						s += "</table>";
						return s;
					},

					getFirstNonClosed: function () {
						while (this.firstEmpty[this.firstNonClosed] == -1) {
							this.firstNonClosed++;
						}
						return this.firstNonClosed;
					},

					setAsCosetTable: function () {
						this.generatorCosetLookup = new Map();
					},

					setCosetEntry: function (cosetRow, g, newCoset) {
						this.rows[cosetRow][g] = newCoset;
						this.generatorCosetLookup.set(g * 100000 + newCoset, cosetRow);
					},

					// Check whether the coset table has an entry for generator 'g', which points to 'coset'.
					findRowPointingToCoset: function (g, coset) {
						return this.generatorCosetLookup.get(g * 100000 + coset);
					},


					addRow: function (coset) {
						this.rowCosets.push(coset);
						this.rowForCoset.set(coset, this.rowCosets.length - 1);
						this.rows.push(new Array(this.genList.length));

					},

					addRelationRow: function (coset) {
						if (this.isSubgroup) return;
						this.addRow(coset);
						var r = this.rows[this.rows.length - 1];
						r[r.length - 1] = coset;
						this.firstEmpty.push(0);
						this.lastEmpty.push(r.length - 2);
					},

					getCosetRow: function (coset) {
						return this.rowForCoset.get(coset);
					},

					set: function (row, col, value) {
						this.rows[row][col] = value;
						var closed = false;
						if (this.firstEmpty[row] == col) {
							if (this.rows[row][col + 1] == undefined) {
								this.firstEmpty[row] = col + 1;
							} else {
								this.firstEmpty[row] = -1;
								this.lastEmpty[row] = -1;
								closed = true;
							}
						}
						if (this.lastEmpty[row] == col) {
							if (col == 0) {
								throw "Unexpected";
							}
							if (this.rows[row][col - 1] == undefined) {
								this.lastEmpty[row] = col - 1;
							} else {
								this.firstEmpty[row] = -1;
								this.lastEmpty[row] = -1;
								closed = true;
							}
						}

						return closed;
					}
				}

				function parseString(generatorMap, string) {
					var rules =  string.replace(/\s/g, ''); // strip whitespace
					rules = rules.split(",");
					var list = [];
					rules.forEach(function (r) {
						var rel = [];
						for (var i = 0; i < r.length; i++) {
							var genIndex = generatorMap.get(r[i]);
							rel.push(genIndex);
						}
						list.push(rel);
					});
					return list;
				}

				function Relations(relationString) {
					relationString = relationString.replace(/\s/g, ''); // strip whitespace
					console.log("Relations:", relationString);

					this.generators = [];
					var self = this;
					
					var set = new Set();
					var stripped = relationString.replace(/,/g, '');
					for (var i = 0; i < stripped.length; i++) set.add(stripped[i]);
					set.forEach(function(v) { self.generators.push(v)});


					this.genMap = new Map();
					for (var i = 0; i < this.generators.length; i++) {
						this.genMap.set(this.generators[i], i);
					}

				//	console.log("Generators:", this.generators);
					
					this.list = parseString(this.genMap, relationString);
					//this.printRelations();
				}

				Relations.prototype = {
					constructor: Relations,

					build: function () { },

					printRelations: function () {
						var self = this;
						this.list.forEach(function (r) {
							console.log(self.toSymbols(r));
						});
					},

					toSymbols: function (list) {
						var self = this;
						return list.reduce(function(s, e) { return s + self.generators[e]}, "");
					}
				}

				function ToddCoxeter(relationString, subgroupString) {
					relationString = relationString.replace(/;/g, ',');
					
					this.rels = new Relations(relationString);
					var gs = [];
					for (var i = 0; i < this.rels.generators.length; i++) gs.push(i);
					this.cosetTable = new Table("Coset", gs);
					this.cosetTable.setAsCosetTable();
					this.cosetTable.addRow(0);

					this.newInformation = [];

					this.relationTables = [];

					for (var i = 0; i < this.rels.list.length; i++) {
						var t = new Table("R" + i, this.rels.list[i]);
						t.addRelationRow(0);
						this.relationTables.push(t);
					}

					if (subgroupString != undefined) {
						subgroupString = subgroupString.replace(/;/g, ',');
						console.log("subgroupString:", subgroupString);
						var subgroupList = parseString(this.rels.genMap, subgroupString);

						for (var i = 0; i < subgroupList.length; i++) {
						
							var subgroup = subgroupList[i];
							if (subgroup.length == 1) {
								// No need to create a subgroup table - we will just fill in the coset table to begin with
								this.cosetTable.rows[0][subgroup[0]] = 0;
							} else {
								var t = new Table("Subgroup " + i, subgroup);
								t.addRelationRow(0);
								t.isSubgroup = true;
								this.relationTables.push(t);
							}
						}
					}

					//this.debugState();

				}

				ToddCoxeter.prototype = {
					constructor: ToddCoxeter,

					debugState: function () {
						var self = this;
						var mapper = function (e) { return self.rels.generators[e]; };
						var out = this.cosetTable.toHTML(mapper) + " <p></p>";

						for (var i = 0; i < this.relationTables.length; i++) {
							out += this.relationTables[i].toHTML(mapper) + " <p></p>";
						}

						document.getElementById('tables').innerHTML = out;

					},

					addRow: function (coset) {
						this.rowCosets.push(coset);
						this.rows.push(new Array(this.genList.length));
					},



					solve: function () {
						var startTime = Date.now();
						var cosetCounter = 1; // Initially we have one coset.
						var self = this;

						var firstEmptyCosetEntryX = 0;
						
						// Returns (row, coset, generatorIndex)
						function firstEmptyCosetEntry() {
							for (var row = firstEmptyCosetEntryX; row < self.cosetTable.rows.length; row++) {
								var coset = self.cosetTable.rowCosets[row];
								for (var col = 0; col < self.cosetTable.rows[row].length; col++) {
									if (self.cosetTable.rows[row][col] == undefined) {
										firstEmptyCosetEntryX = row;
						
										return [row, coset, col];
									}
								}
							}
							return undefined;
						}

						function updateRelationTable2() {
							for (var i = 0; i < self.relationTables.length; i++) {
								var rt = self.relationTables[i];

								for (var row = rt.getFirstNonClosed(); row < rt.rows.length; row++) {

									var changes = true;

									while (changes) {
										changes = false;

										// Check from left
										var firstEmpty = rt.firstEmpty[row];
										if (firstEmpty == -1) continue;

										if (rt.rows[row][firstEmpty] !== undefined) throw "Inconsistent state";

										var coset = (firstEmpty == 0 ? rt.rowCosets[row] : rt.rows[row][firstEmpty - 1]);
										var gen = rt.genList[firstEmpty];

										if (debug) console.log(rt.name + "[" + row + "," + firstEmpty + "] First empty: coset: " + coset + " gen:" + gen);
										var cTableRow = self.cosetTable.getCosetRow(coset);
										var newCoset = self.cosetTable.rows[cTableRow][gen];
										if (newCoset != undefined) {
											var closed = rt.set(row, firstEmpty, newCoset);
											if (closed) {
												// New information: newCoset * rt.genList[firstEmpty+1] = rt.rows[row][firstEmpty+1]
												if (debug) console.log("New information (left): " + newCoset + " * g" + rt.genList[firstEmpty + 1] + " = " + rt.rows[row][firstEmpty + 1]);
												self.newInformation.push([newCoset, rt.genList[firstEmpty + 1], rt.rows[row][firstEmpty + 1]]);

											} else {
												changes = true;
											}
										}

										// Check from right
										if (rt.lastEmpty[row] == -1) continue;
										var lastEmpty = rt.lastEmpty[row];
										//if (rt.rows[row][lastEmpty] !== undefined) throw "Inconsistent state";

										var newCoset = rt.rows[row][lastEmpty + 1];
										var gen = rt.genList[lastEmpty + 1];

										if (debug) console.log(rt.name + "[" + row + "," + lastEmpty + "] Last empty: newCoset: " + newCoset + " gen:" + gen);

										var ctRow = self.cosetTable.findRowPointingToCoset(gen, newCoset);
										if (ctRow != undefined) {
											var closed = rt.set(row, lastEmpty, self.cosetTable.rowCosets[ctRow]);
											if (closed) {
												var coset = (lastEmpty > 0 ? rt.rows[row][lastEmpty - 1] : rt.rowCosets[row]);
												if (debug) console.log("New information (right): " + coset + " * g" + rt.genList[lastEmpty] + " = " + self.cosetTable.rowCosets[ctRow]);
												if (coset == undefined) {
													debugger;
												}
												self.newInformation.push(
													[coset, rt.genList[lastEmpty], self.cosetTable.rowCosets[ctRow]]);

											} else {
												changes = true;
											}
										}

									}
								}
							}
						}


						function addCoset(newCoset) {
							for (var i = 0; i < self.relationTables.length; i++) {
								var rt = self.relationTables[i];
								rt.addRelationRow(newCoset);
							}
							self.cosetTable.addRow(newCoset);
						}


						for (; ;) {
							if (cosetCounter > 15000) {
								break;
							}
							if (this.newInformation.length == 0) {
								// Find first empty entry in coset table.
								var entry = firstEmptyCosetEntry();
								if (entry == undefined) break;

								var newCoset = cosetCounter++;
								var row = entry[0];
								var coset = entry[1];
								var g = entry[2];
								this.cosetTable.setCosetEntry(row, g, newCoset);
								//this.cosetTable.rows[row][g] = newCoset;

								addCoset(newCoset);

								// The reverse relation must be present as well.
								var newCosetRow = this.cosetTable.getCosetRow(newCoset);

								//this.cosetTable.rows[newCosetRow][g] = coset;
								this.cosetTable.setCosetEntry(newCosetRow, g, coset);

							} else {
								while (this.newInformation.length > 0) {
									var i = this.newInformation.pop();

									// coset*g = newCoset
									var coset = i[0];
									var g = i[1];
									var newCoset = i[2];

									var cosetRow = this.cosetTable.getCosetRow(coset);
									var val = this.cosetTable.rows[cosetRow][g];

									if (val == undefined) {
										//this.cosetTable.rows[cosetRow][g] = newCoset;
										this.cosetTable.setCosetEntry(cosetRow, g, newCoset);

									} else {
										if (val != newCoset) {
											debugger;
										}
									}

									// per symmetry: newCoset*g = coset
									var cosetRow = this.cosetTable.getCosetRow(newCoset);
									var val = this.cosetTable.rows[cosetRow][g];
									if (val == undefined) {
										//this.cosetTable.rows[cosetRow][g] = coset;
										this.cosetTable.setCosetEntry(cosetRow, g, coset);

									} else {
										if (val != coset) {
											debugger;
										}
									}


								}
							}

							updateRelationTable2();

								//	this.debugState();
							//	debugger;
						}

						console.log("Elapsed: " + (Date.now() - startTime) + " ms. Cosets: " + this.cosetTable.rows.length);
						this.cosetCounts = this.cosetTable.rows.length;
						console.log(" ");
						return this.cosetCounts;
					},

					getCosetCounts() {
						return this.cosetCounts;			
					}
				}

				//var tc = new ToddCoxeter(input, "RBRB");
				//r-4-g-3-b-3-a
				var s = "rgrgrgrg;gbgbgb;bababa;rbrb;rara;gaga";
				/*
				var tc = new ToddCoxeter(s);
				tc.solve();
				
				var tc = new ToddCoxeter(s,"g;b;a");
				tc.solve();
				var tc = new ToddCoxeter(s,"r;b;a");
				tc.solve();
			
				var tc = new ToddCoxeter(s,"r;g;a");
				tc.solve();

				var tc = new ToddCoxeter(s,"r;g;b");
				tc.solve();
*/
			
			
				function subgroups(powers,name) {
					var gs = "rgba";
					var s = "";
					for (var i = 0; i < powers.length; i++) {
						for(var p = 0; p<powers[i]; p++){s+=gs[i]+gs[i+1];}
						s+=";";
					}
					for (var i = 0; i < powers.length; i++) {
						for (var j = i+2; j<powers.length+1;j++){s+=gs[i]+gs[j]+gs[i]+gs[j]+";";} 
					}
					s= s.slice(0, -1);
					
					var hlist = [];
					for (var i = 0; i < powers.length+1; i++) {
						var hs = "";
						for (var j = 0; j < powers.length+1; j++) {
							if (j!=i) hs+= gs[j] + ";";
						}
						hs= hs.slice(0, -1);

						hlist.push(hs);
					}
					console.log(s);
					console.log(hlist);

					var out = "<table  class='blueTable'><thead><th></th><th>" + s + "</th>";
					for (var i =0 ; i< hlist.length;i++) out+="<th>" + hlist[i] + "</th>";
					out += "</thead>";

					var tc = new ToddCoxeter(s);
					var total = tc.solve();
					var subs = [];
					for (var i = 0; i < hlist.length; i++) {
						var tc = new ToddCoxeter(s,hlist[i]);
						subs.push( tc.solve());
					}

					 out += "<tr><td>" + name+ "</td><td>" + total + "</td>";
					for (var i =0 ; i< subs.length;i++) out+="<td>" + subs[i] + "</td>";
					out += "</tr>";
					out +="</table>";
					document.getElementById('tables').innerHTML = "<span>" +document.getElementById('tables').innerHTML + out + "</span>";
				}

				document.getElementById('tables').innerHTML = "";
				
				subgroups([3,3], "Tetrahedron");
				subgroups([4,3], "Cube");
				subgroups([3,4], "Octahedron");
				subgroups([5,3], "Dodecahedron");
				subgroups([3,5], "Icosahedron");

				subgroups([3,3,3], "5-cell");
				subgroups([4,3,3], "8-cell");
				subgroups([3,3,4], "16-cell");
				subgroups([5,3,3], "120-cell");
				subgroups([3,3,5], "600-cell");


		//		var tc = new ToddCoxeter("ababababab,bcbcbc,cdcdcd,acac,adad,bdbd");
		//		tc.solve();
/*
				var tc = new ToddCoxeter("ababababab,bcbcbc,acac");
				tc.solve();
				var tc = new ToddCoxeter("abababab,bcbcbc,cdcdcd,acac,adad,bdbd");
				tc.solve();

				var tc = new ToddCoxeter("ababab,bcbcbcbc,cdcdcd,acac,adad,bdbd");
				tc.solve();

				var tc = new ToddCoxeter("ababab,bcbcbcbc,cdcdcd,acac,adad,bdbd", "bcd");
				tc.solve();


				var tc = new ToddCoxeter("ababababab,bcbcbc,cdcdcd,acac,adad,bdbd", "b");
				tc.solve();
				var tc = new ToddCoxeter("ababababab,bcbcbc,cdcdcd,acac,adad,bdbd", "bc");
				tc.solve();
				var tc = new ToddCoxeter("ababababab,bcbcbc,cdcdcd,acac,adad,bdbd", "ac");
				tc.solve();
				var tc = new ToddCoxeter("ababababab,bcbcbc,cdcdcd,acac,adad,bdbd", "abc");
				tc.solve();
Cartan matrices: https://arxiv.org/pdf/math/0311012.pdf
Tits' theorem: https://people.math.ethz.ch/~ykrifka/docs/lecturenotes.pdf

*/
			</script>


</body>

</html>