<!DOCTYPE html>
<html lang="en">

<head>
	<title>threejs webgl - materials - transparency</title>
	<style>
		body {
			color: #000;
			background-color: #fff;
			margin-left: 240px;
			width: 1000px;

		}

		body {
			font-family: 'Libre Baskerville', sans-serif;
		}

		h1,
		h2,
		h3,
		h4 {
			font-family: 'Libre Baskerville', sans-serif;
		}

		table.blueTable {
			//border: 1px solid #1C6EA4;
			background-color: #EEEEEE;
			text-align: left;
			border-collapse: collapse;
			display: inline-block;
			float: left;
			padding: 10px;
			font-size: 8px;
		}

		table.blueTable td,
		table.blueTable th {
			border: 1px solid #AAAAAA;
			padding: 3px 2px;
		}

		table.blueTable tbody td {
			font-size: 8px;
		}

		table.blueTable tr:nth-child(even) {
			background: #D0E4F5;
		}

		table.blueTable thead {
			background: rgb(231, 243, 253);
		}

		table.blueTable thead th {
			font-size: 10px;
		}
	</style>
	<link href="https://fonts.googleapis.com/css?family=Libre+Baskerville|Open+Sans" rel="stylesheet">
</head>

<body>

	<div id="container"></div>
	<script src="js/three.min.js" type="text/javascript"></script>
	<script src="js/OrbitControls.js" type="text/javascript"></script>
	<script src="js/Detector.js" type="text/javascript"></script>
	<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML"></script>
	<h1>Stereographic projection</h1>
	<p>
		<em>Jenn is a toy for playing with various quotients of Cayley graphs of finite Coxeter groups on four generators. Jenn builds
			the graphs using the Todd-Coxeter algorithm, embeds them into the 3-sphere, and stereographically projects them onto euclidean
			3-space.
		</em>


	</p>


	<p>
		<a href="https://terrytao.wordpress.com/2010/07/10/cayley-graphs-and-the-geometry-of-groups/">Cayley graphs</a>
		<br/>
		<a href="https://math.berkeley.edu/~kmill/notes/todd_coxeter.html">Todd Coxeter</a>
		<br/>
		<a href="https://math.stackexchange.com/questions/259545/meaning-of-a-regular-polytope">Meaning of regular polytope</a>
		<br/>
		<a href="https://math.stackexchange.com/questions/735679/what-is-the-coxeter-diagram-for/764753">What is Coxeter diagram?</a>
		<br/>
		<a href="http://www.ams.org/notices/199706/seress.pdf2">An introduction to computational group theory</a>
	</p>




	<h2>Example: symmetries of the cube</h2>
	<p>
		Let us start with a simple three dimensional cube. </p>

	<p>This cube has several automorphisms - transformations that will map the cube onto itself. For instance, we can easily find
		several rotations (from vertex to opposite vertex: 4 (120 degrees), from mid-edge to opposite mid-edge: 6 (180 degrees),
		from mid-face to opposite face: 3 (90 degrees): a total of: 4*2+6*1+3*3 = 23 rotations.
	</p>
	<p>
		Including the identity transformation, and taking into account that we could also mirror these transformations (parity flip)
		every one of these transformations, we arrive at
		<b>48</b> automorphisms of the cube.
	</p>
	<p>These transformations form a
		<em>group</em>: which mathematically, is a set of elements, together with an operation for combining any two elements such
		that the results is again an element in the set. There muse an identity element in the group, and every element must have
		an inverse element: i.e. an element such that combining the element and its inverse, results in the identity element. In
		our case, combining any number of the 48 transformations will result in a transformation that is already in the present
		in our set of transformations. Likewise, for all rotations and reflections there exists an inverse transformation (for
		180 degrees transformations, and for reflections, these transformations are their own inverses).
	</p>

	<p>
		Generators: a subset, S, of elements in the group G, which can be used to express all elements (using their inverses as well).
	</p>

	<p>
		Coxeter group: relations on the form \((ab)^{m_{ab}}\).
	</p>


	<script>

		function createLine(from, to, width, color) {
			var m = new THREE.MeshStandardMaterial({
				color: color,
			});
			var dist = from.distanceTo(to);

			var geometry = new THREE.CylinderGeometry(width, width, dist, 20, 1);
			var mesh = new THREE.Mesh(geometry, m);
			var axis = new THREE.Vector3(0, 1, 0);
			var vector = (new THREE.Vector3()).subVectors(to, from);
			mesh.quaternion.setFromUnitVectors(axis, vector.clone().normalize());
			mesh.position.copy(from.clone().addScaledVector(vector, 0.5));
			return mesh;
		}

		function createPlane(v1, v2, v4, color) {
			var m = new THREE.MeshStandardMaterial({
				opacity: 0.8,
				transparent: true,
				side: THREE.DoubleSide,
				color: color,
			});

			var g = new THREE.Geometry();

			var d1 = new THREE.Vector3().addScaledVector(v2, 1).addScaledVector(v1, -1);
			var d2 = new THREE.Vector3().addScaledVector(v4, 1).addScaledVector(v1, -1);

			var divs = 14;
			var offset = 0;
			for (var i = 0; i < divs; i++) {
				for (var j = 0; j < divs; j++) {
					var x1 = new THREE.Vector3().addScaledVector(v1, 1).addScaledVector(d1, i / divs).addScaledVector(d2, j / divs);
					var x2 = new THREE.Vector3().addScaledVector(v1, 1).addScaledVector(d1, (i + 1) / divs).addScaledVector(d2, j / divs);
					var x3 = new THREE.Vector3().addScaledVector(v1, 1).addScaledVector(d1, i / divs).addScaledVector(d2, (j + 1) / divs);
					var x4 = new THREE.Vector3().addScaledVector(v1, 1).addScaledVector(d1, (i + 1) / divs).addScaledVector(d2, (j + 1) / divs);
					g.vertices.push(x1, x2, x4, x3);
					g.faces.push(new THREE.Face3(offset, offset + 1, offset + 2), new THREE.Face3(offset + 2, offset + 3, offset));
					offset += 4;
				}
			}
			g.computeFlatVertexNormals();
			return new THREE.Mesh(g, m);
		}


		function getStandard3DView(container, w, h) {
			var camera = new THREE.PerspectiveCamera(40, w / h, 1, 2000);
			camera.position.set(0.0, 1.2, 1.2 * 3.5);
			var scene2 = new THREE.Scene( { antialias: true });
			scene2.background = new THREE.Color(0xffffff);
			scene2.add(camera);

			var ambientLight = new THREE.AmbientLight(0xffffff);
			camera.add(ambientLight);
			var directionalLight = new THREE.DirectionalLight(0xffffff, 1);
			directionalLight.position.set(0, 2, 9);
			camera.add(directionalLight);

			var renderer = new THREE.WebGLRenderer();
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(w, h);
			container.appendChild(renderer.domElement);

			var controls = new THREE.OrbitControls(camera, renderer.domElement);
			controls.addEventListener('change', function () { renderer.render(scene2, camera); });

			setTimeout(function () { renderer.render(scene2, camera) });
			return scene2;
		}

		function mid(v1, v2) {
			return new THREE.Vector3().addScaledVector(v1, 0.5).addScaledVector(v2, 0.5);
		}

		function getSideWidth() {
			return 300;
		}

		function getContainer(offset) {
			var container = document.createElement('div');
			container.style.position = "absolute";
			var inner = document.createElement('div');
			inner.style.position = "relative";
			inner.style.left = "1000px";
			inner.style.top = offset + "px";
			inner.style.width = getSideWidth() + "px";
			container.appendChild(inner);
			document.body.appendChild(container);
			return inner;
		}
		if (!Detector.webgl) Detector.addGetWebGLMessage();

		function getVertices() {
			var v = [new THREE.Vector3(-1, -1, -1), new THREE.Vector3(-1, 1, -1), new THREE.Vector3(1, 1, -1), new THREE.Vector3(1, -1, -1),
				new THREE.Vector3(-1, -1, 1), new THREE.Vector3(-1, 1, 1), new THREE.Vector3(1, 1, 1), new THREE.Vector3(1, -1, 1)];
				return v;
		};

		function getEdges() {
			var v = getVertices();
			var e = [];
			e.push(v[0], v[1], v[1], v[2], v[2], v[3], v[3], v[0]);
			e.push(v[4], v[5], v[5], v[6], v[6], v[7], v[7], v[4]);
			e.push(v[0], v[4], v[1], v[5], v[2], v[6], v[3], v[7]);
			return e;
		};
	</script>


	<script>

		

		init();
		function init() {
			var scene = getStandard3DView(getContainer(20), getSideWidth(), getSideWidth());

			var v = getVertices();
			var e = getEdges();

			scene.add(createPlane(v[0], v[1], v[3], 0xff0000)); // top
			scene.add(createPlane(v[5], v[6], v[4], 0xff0000)); // bottom
			scene.add(createPlane(v[3], v[2], v[7], 0x00ff00)); // right
			scene.add(createPlane(v[0], v[1], v[4], 0x00ff00)); // left
			scene.add(createPlane(v[0], v[3], v[4], 0x0000ff)); // front
			scene.add(createPlane(v[1], v[2], v[5], 0x0000ff)); // back

			v.forEach(function (vv) { vv.multiplyScalar(1.3); });
			var w = 0.05;
			var c = 0xffffff;
			scene.add(createLine(v[0], v[6], w, c));
			scene.add(createLine(v[1], v[7], w, c));
			scene.add(createLine(v[2], v[4], w, c));
			scene.add(createLine(v[3], v[5], w, c));


			var l = 1.5; w = 0.05; c = 0xff5566;
			scene.add(createLine(new THREE.Vector3(-l, 0, 0), new THREE.Vector3(l, 0, 0), w, c));
			scene.add(createLine(new THREE.Vector3(0, -l, 0), new THREE.Vector3(0, l, 0), w, c));
			scene.add(createLine(new THREE.Vector3(0, 0, -l), new THREE.Vector3(0, 0, l), w, c));
			var  c = 0x5566ff;
			for (var i = 0; i < e.length; i += 2) {
				var v1 = mid(e[i],e[i+1]).multiplyScalar(1.2);
				var v2 = v1.clone().multiplyScalar(-1);
				scene.add(createLine(v1,v2, w, c));
			}
		}
	</script>


	<script>
		function init() {
			var scene = getStandard3DView(getContainer(getSideWidth() + 20), getSideWidth(), getSideWidth());

			var v = getVertices();
			var e = getEdges();

			for (var i = 0; i < e.length; i += 2) {
				scene.add(createLine(e[i], e[i + 1], 0.02, 0xffffff));
			}
			scene.add(createPlane(v[0], v[2], v[4], 0xff0000));
			scene.add(createPlane(v[1], v[3], v[5], 0xff0000));
			scene.add(createPlane(v[0], v[3], v[5], 0x00ff00));
			scene.add(createPlane(v[1], v[2], v[4], 0x00ff00));
			scene.add(createPlane(v[4], v[5], v[3], 0x333333));
			scene.add(createPlane(v[0], v[1], v[7], 0x333333));
			scene.add(createPlane(mid(v[0], v[3]), mid(v[1], v[2]), mid(v[4], v[7]), 0x0000ff));
			scene.add(createPlane(mid(v[0], v[1]), mid(v[2], v[3]), mid(v[4], v[5]), 0x0000ff));
			scene.add(createPlane(mid(v[0], v[4]), mid(v[3], v[7]), mid(v[1], v[5]), 0x0000ff));
		}

		init();


	</script>


	<script>

		function init() {
			var scene = getStandard3DView(getContainer(2 * (getSideWidth() + 20)), getSideWidth(), getSideWidth());

			var v = getVertices();
			var e = getEdges();
			
			for (var i = 0; i < e.length; i += 2) {
				scene.add(createLine(e[i], e[i + 1], 0.02, 0xffffff));
			}

			scene.add(createPlane(v[0], v[2], v[4], 0x00ff00));
			scene.add(createPlane(v[0], v[3], v[5], 0x0000ff));
			scene.add(createPlane(mid(v[0], v[3]), mid(v[1], v[2]), mid(v[4], v[7]), 0xff0000));
		}


		init();

	</script>

	<p>
		Here we have three reflection planes, which we could think of as operators: R, G, and B.
	</p>
	<p>
		Notice that the angle between the reflection planes are: $$\angle(R,G) = 45^{\circ} $$ $$\angle(G,B) = 60^{\circ} $$ $$\angle(R,B)
		= 90^{\circ} $$
	</p>
	<p>
		Now, combining two reflections, result in a rotation of twice the angle between the reflection planes. So applying e.g. GR
		would be equal to a rotation of 120 degrees. And applying GR three times, e.g. GRGRGR, would not change the input.
	</p>
	<p>This means we can establish the following relations between the generators:</p>
	$$R^2 = B^2 = G^2 = (RG)^4 = (GB)^3 = (RB)^2 = I$$
	<p>
		Now, given this set of generators, how many different elements are there in our set? For instance, are (RBGR)^n different
		elements for all n? This turns out to be a computationally hard problem, known as the
		<a href="https://en.wikipedia.org/wiki/Word_problem_for_groups">word problem for groups</a>.
	</p>

	<h2>The Todd-Coexeter Algorithm</h2>

	<p>
		The
		<a href="https://en.wikipedia.org/wiki/Todd%E2%80%93Coxeter_algorithm">Todd-Coxeter Algorithm</a> a provides a way to identify and count all elements generated by our generators.
	</p>
	<p>Actually, the algorithm does a bit more: it allows for enumerating all cosets of G, for a given subgroup H. What does this
		mean?
		<br>A coset is the set resulting by multiplying the all members in \(H\) by a group element from, \(g\). A (left) coset is
		written \(gH\). The number of cosets is written \(|G:H|\). Lagrange's theorem states that \( [G:H]={|G| \over |H|} \).

	</p>

	<p>
		<table class="blueTable">
			<thead>
				<th>name</th>
				<th>generators</th>
				<th>free count</th>
				<th>g;b;</th>
				<th>r;b;</th>
				<th>r;g;</th>
				</tr>
			</thead>
			<tbody>
				<tr>
					<td>Tetrahedron</td>
					<td>rgrgrg;gbgbgb;rbrb;</td>
					<td>24</td>
					<td>4</td>
					<td>6</td>
					<td>4</td>
				</tr>
				<tr>
					<td>Cube</td>
					<td>rgrgrgrg;gbgbgb;rbrb;</td>
					<td>48</td>
					<td>8</td>
					<td>12</td>
					<td>6</td>
				</tr>
				<tr>
					<td>Octahedron</td>
					<td>rgrgrg;gbgbgbgb;rbrb;</td>
					<td>48</td>
					<td>6</td>
					<td>12</td>
					<td>8</td>
				</tr>
				<tr>
					<td>Dodecahedron</td>
					<td>rgrgrgrgrg;gbgbgb;rbrb;</td>
					<td>120</td>
					<td>20</td>
					<td>30</td>
					<td>12</td>
				</tr>
				<tr>
					<td>Icosahedron</td>
					<td>rgrgrg;gbgbgbgbgb;rbrb;</td>
					<td>120</td>
					<td>12</td>
					<td>30</td>
					<td>20</td>
				</tr>
			</tbody>
		</table>
		<table class="blueTable">

			<thead>
				<th>name</th>
				<th>generators</th>
				<th>free count</th>
				<th>g;b;a;</th>
				<th>r;b;a;</th>
				<th>r;g;a;</th>
				<th>r;g;b;</th>
				</tr>
			</thead>
			<tbody>
				<tr>
					<td>5-cell</td>
					<td>rgrgrg;gbgbgb;bababa;rbrb;rara;gaga;</td>
					<td>120</td>
					<td>5</td>
					<td>10</td>
					<td>10</td>
					<td>5</td>
				</tr>
				<tr>
					<td>8-cell</td>
					<td>rgrgrgrg;gbgbgb;bababa;rbrb;rara;gaga;</td>
					<td>384</td>
					<td>16</td>
					<td>32</td>
					<td>24</td>
					<td>8</td>
				</tr>
				<tr>
					<td>16-cell</td>
					<td>rgrgrg;gbgbgb;babababa;rbrb;rara;gaga;</td>
					<td>384</td>
					<td>8</td>
					<td>24</td>
					<td>32</td>
					<td>16</td>
				</tr>
				<tr>
					<td>120-cell</td>
					<td>rgrgrgrgrg;gbgbgb;bababa;rbrb;rara;gaga;</td>
					<td>14400</td>
					<td>600</td>
					<td>1200</td>
					<td>720</td>
					<td>120</td>
				</tr>
				<tr>
					<td>600-cell</td>
					<td>rgrgrg;gbgbgb;bababababa;rbrb;rara;gaga;</td>
					<td>14400</td>
					<td>120</td>
					<td>720</td>
					<td>1200</td>
					<td>600</td>
				</tr>
			</tbody>
		</table>

	</p>

	<script>

		function init() {
			var container = document.createElement('div');
			container.style.width = "600px";
			container.style.height = "600px";
			document.body.appendChild(container);

			var scene = getStandard3DView(container, 600, 600);

			var v = [new THREE.Vector3(-1, -1, -1), new THREE.Vector3(-1, 1, -1), new THREE.Vector3(1, 1, -1), new THREE.Vector3(1, -1, -1),
			new THREE.Vector3(-1, -1, 1), new THREE.Vector3(-1, 1, 1), new THREE.Vector3(1, 1, 1), new THREE.Vector3(1, -1, 1)];

			var vertices = [];
			vertices.push(v[0], v[1], v[1], v[2], v[2], v[3], v[3], v[0]);
			vertices.push(v[4], v[5], v[5], v[6], v[6], v[7], v[7], v[4]);
			vertices.push(v[0], v[4], v[1], v[5], v[2], v[6], v[3], v[7]);
			for (var i = 0; i < vertices.length; i += 2) {
				scene.add(createLine(vertices[i], vertices[i + 1], 0.02, 0xffffff));
			}

			scene.add(createPlane(v[0], v[2], v[4], 0x00ff00));
			scene.add(createPlane(v[0], v[3], v[5], 0x0000ff));
			scene.add(createPlane(mid(v[0], v[3]), mid(v[1], v[2]), mid(v[4], v[7]), 0xff0000));
		}


		init();
	//https://math.berkeley.edu/~kmill/tools/tc.html rr; gg; bb; rbrbrbrb; grgrgr; gbgb; GRGRGR = I GR = I

	</script>


	<h2>Projection</h2>



	</script>

</body>

</html>