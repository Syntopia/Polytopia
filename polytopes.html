<!DOCTYPE html>
<html lang="en">

<head>
	<title>Polytopes and Coxeter Groups</title>
	<link rel='stylesheet' href='style.css' type='text/css' />
	<link rel='stylesheet' href='datgui.css' type='text/css' />
	<link href="https://fonts.googleapis.com/css?family=Cinzel+Decorative" rel="stylesheet">
</head>

<body>
	<script src="js/three.min.js" type="text/javascript"></script>
	<script src="js/OrbitControls.js" type="text/javascript"></script>
	<script src="js/Detector.js" type="text/javascript"></script>
	<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/svg.js/2.6.4/svg.js" integrity="sha256-Vfh4R0uOWH2tv2NrGrtTZUo+hRBMGtEczBeTz3CSvj4="
	 crossorigin="anonymous"></script>
	<script src="toddcoxeter.js" type="text/javascript"></script>
	<script src="utils.js" type="text/javascript"></script>
	<script src="js/dat.gui.min.js" type="text/javascript"></script>
	<script>
		var showSceneObjects;
	</script>
	<div class="header">
		<h1>Building 4D polytopes</h1>
		<div class="author">by Mikael Hvidtfeldt Christensen,
			<a href="https://twitter.com/syntopiadk?lang=en">@SyntopiaDK</a>
		</div>
		<p>Years ago I stumbled upon the
			<a href="http://blog.hvidtfeldts.net/index.php/2012/02/distance-estimated-polychora/">convex regular 4-polytopes</a> - four-dimensional analogues of the Platonic solids. I did not understand the mathematics
			behind these structures back then - but recently I decided to figure out how this works.
	</p>
		<p>
			<em>This page is not mobile friendly. While some content might be viewable, the WebGL stuff will likely not work. The page
				is best viewed with Chrome, and with a discrete GPU enabled (for the ray traced stuff).
			</em>
		</p>
	</div>


	<div class="mainContent" id="main">
		<p>
			My first encounter with four-dimensional polytopes was
			<a href="https://www.math.cmu.edu/~fho/jenn/">Jenn 3D</a> (2001-2007) by
			<a href="http://fritzo.org/">Fritz Obermeyer</a>. Jenn describes itself as follows:</p>
		<p>
			<em>Jenn is a toy for playing with various quotients of Cayley graphs of finite Coxeter groups on four generators. Jenn builds
				the graphs using the Todd-Coxeter algorithm, embeds them into the 3-sphere, and stereographically projects them onto
				Euclidean 3-space.
			</em>
		</p>
		<p>
			Wow. This description made absolutely no sense to me when I first read it - none of these terms were familiar to me. My 
			purpose with this page is to go through this description step-by-step and explain the various terms.
		</p>
		<p>
			We will also go one step further, and discuss how these structures can be ray traced in realtime. This can be done using a
			clever (inverse) construction technique of
			<em>folding</em> space into a fundamental domain. The technique was originally described by
			<a href="https://plus.google.com/114982179961753756261">Abdelaziz Nait Merzouk</a> (aka Knighty) in a
			<a href="http://www.fractalforums.com/fragmentarium/solids-many-many-solids/">Fractal Forums thread</a> from 2012.
		</p>

		<div class="fullwidth">
			<img src="img3.jpg" width="100%" />
		</div>
		<h2>Symmetries of the cube</h2>
		<p>
			We will start out in three dimensions with a familiar object: the cube. </p>
		<div class="rightBox" id="rboxSimple">
		</div>

		<script>
			function sceneAdd(scene, object, group) {
				if (scene.groupings == undefined) {
					scene.groupings = new Map();
				}
				if (scene.groupings.get(group) == undefined) {
					scene.groupings.set(group, []);
				}
				scene.groupings.get(group).push(object);
				scene.add(object);
			}

			init();
			function init() {
				var d = document.getElementById("rboxSimple");

				var scene = getStandard3DView(d, getSideWidth(), getSideWidth());

				var v = getVertices();
				var e = getEdges();

				scene.add(createPlane(v[0], v[1], v[3], 0xff0000)); // top
				scene.add(createPlane(v[5], v[6], v[4], 0xff0000)); // bottom
				scene.add(createPlane(v[3], v[2], v[7], 0x00ff00)); // right
				scene.add(createPlane(v[0], v[1], v[4], 0x00ff00)); // left
				scene.add(createPlane(v[0], v[3], v[4], 0x0000ff)); // front
				scene.add(createPlane(v[1], v[2], v[5], 0x0000ff)); // back

				v.forEach(function (vv) { vv.multiplyScalar(1.3); });
				var w = 0.05;
				var c = 0xffffff;
				sceneAdd(scene, createLine(v[0], v[6], w, c), "vertices");
				sceneAdd(scene, createLine(v[1], v[7], w, c), "vertices");
				sceneAdd(scene, createLine(v[2], v[4], w, c), "vertices");
				sceneAdd(scene, createLine(v[3], v[5], w, c), "vertices");

				showSceneObjects = function (category) {
					scene.groupings.forEach(function (c) {
						c.forEach(function (obj) { obj.visible = (category == undefined ? true : false); })
					});
					if (category != undefined)
						scene.groupings.get(category).forEach(function (obj) { obj.visible = true; });
					scene.doRender();
				};

				var l = 1.5; w = 0.05; c = 0xff5566;
				sceneAdd(scene, createLine(new THREE.Vector3(-l, 0, 0), new THREE.Vector3(l, 0, 0), w, c), "faces");
				sceneAdd(scene, createLine(new THREE.Vector3(0, -l, 0), new THREE.Vector3(0, l, 0), w, c), "faces");
				sceneAdd(scene, createLine(new THREE.Vector3(0, 0, -l), new THREE.Vector3(0, 0, l), w, c), "faces");
				var c = 0x5566ff;
				for (var i = 0; i < e.length; i += 2) {
					var v1 = mid(e[i], e[i + 1]).multiplyScalar(1.2);
					var v2 = v1.clone().multiplyScalar(-1);
					sceneAdd(scene, createLine(v1, v2, w, c), "edges");
				}
			}
		</script>

		<div class="rightBox" id="rboxSimple2">
		</div>

		<script>
			function init() {
				var d = document.getElementById("rboxSimple2");
				var scene = getStandard3DView(d, getSideWidth(), getSideWidth());

				var v = getVertices();
				var e = getEdges();

				for (var i = 0; i < e.length; i += 2) {
					scene.add(createLine(e[i], e[i + 1], 0.02, 0xffffff));
				}
				scene.add(createPlane(v[0], v[2], v[4], 0xff0000));
				scene.add(createPlane(v[1], v[3], v[5], 0xff0000));
				scene.add(createPlane(v[0], v[3], v[5], 0x00ff00));
				scene.add(createPlane(v[1], v[2], v[4], 0x00ff00));
				scene.add(createPlane(v[4], v[5], v[3], 0x333333));
				scene.add(createPlane(v[0], v[1], v[7], 0x333333));
				scene.add(createPlane(mid(v[0], v[3]), mid(v[1], v[2]), mid(v[4], v[7]), 0x0000ff));
				scene.add(createPlane(mid(v[0], v[1]), mid(v[2], v[3]), mid(v[4], v[5]), 0x0000ff));
				scene.add(createPlane(mid(v[0], v[4]), mid(v[3], v[7]), mid(v[1], v[5]), 0x0000ff));
			}

			init();
		</script>

		<p>The cube has several
			<em>automorphisms</em> - transformations that will map the cube onto itself. For instance, we can easily find several rotations
			(between
			<a href="" class="interactive" onmouseover="showSceneObjects('vertices')" onmouseout="showSceneObjects()">opposite vertices</a>: 4 (120 degrees), opposite
			<a href="" class="interactive" onmouseover="showSceneObjects('edges')" onmouseout="showSceneObjects()">mid-edges</a>: 6 (180 degrees), and opposite
			<a href="" class="interactive" onmouseover="showSceneObjects('faces')" onmouseout="showSceneObjects()">faces</a>: 3 (90 degrees): a total of 4*2+6*1+3*3 = 23 rotations.
		</p>
		<p> Including the identity transformation, and taking into account that we could also mirror each one of these transformations,
			we arrive at
			<b>48</b> automorphisms for the cube.
		</p>
		<p>
			Besides the rotation symmetries above, we can also depict the reflection symmetries. Shown to the right are the 9 different such reflection operations, that will map the cube onto itself (although in a mirrored
			version).
		</p>
		<p>These 48 transformations form a
			<b>group</b>: a set of elements, together with a rule for combining any two elements such that the result is again an element
			in the set. There must an identity element in the group, and every element must have an inverse element: i.e. an element
			such that combining the element and its inverse results in the identity element.
		</p>
		<p>
			In our case, combining any number of the 48 transformations will result in a transformation that is already present
			in our set of transformations. Likewise, for all rotations and reflections, there exists an inverse transformation (for
			180 degrees rotations, and for reflections, the transformations are their own inverses).
		</p>
		<p>These transformations are not independent: some transformations can be expressed by combining other transformations. Perhaps
			it is possible to find a smaller subset of transformation that could be combined to form all the 48 automorphisms?
		</p>

		<p>
			This is known as a set of
			<b>generators</b>: a subset, S, of elements in the group G, which can be used to express all elements.
		</p>

		<div class="rightBox" id="rbox1">
		</div>

		<script>
			function init() {
				var d = document.getElementById("rbox1");

				var scene = getStandard3DView(d, getSideWidth(), getSideWidth());

				var v = getVertices();
				var e = getEdges();

				for (var i = 0; i < e.length; i += 2) {
					scene.add(createLine(e[i], e[i + 1], 0.02, 0xffffff));
				}

				scene.add(createPlane(v[0], v[2], v[4], 0x00ff00));
				scene.add(createPlane(v[0], v[3], v[5], 0x0000ff));
				scene.add(createPlane(mid(v[0], v[3]), mid(v[1], v[2]), mid(v[4], v[7]), 0xff0000));
			}

			init();
		</script>
		<p>
			For the cube, it is possible to find a set of three reflections, which can be used to form all the 48 transformations. One such
			set is shown to the right: here we have three reflection planes, which we could think of as operators - let us call them
			R, G, and B after their colors. This set can be used to construct all other transformations.
		</p>
		<p>
			Notice that the angle between the reflection planes (sometimes called <b>mirrors</b>) is: $$\angle(R,G) = 45^{\circ} $$ $$\angle(G,B) = 60^{\circ} $$ $$\angle(R,B)
			= 90^{\circ} $$
		</p>
		<p>
			<em>Now, combining two reflections results in a rotation of twice the angle between the reflection planes</em>. So applying e.g. GB
			would be equal to a rotation of 120 degrees. And applying GB three times, e.g. GBGBGB, would not change the input.
		</p>
		<p>This means we can establish the following
			<b>relations</b> between the generators:</p>
		$$R^2 = B^2 = G^2 = (RG)^4 = (GB)^3 = (RB)^2 = I$$
		<p>
			Given a set of generators, how many different elements are there in our set? And can
			we decide whether two compositions (say RGRG and RBG) are identical operations? This turns out to be a computationally hard problem, known as the
			<a href="https://en.wikipedia.org/wiki/Word_problem_for_groups">word problem for groups</a>. But for some specific groups, this problem is computationally
			tractable.
		</p>
		<div class="fullwidth">
			<img src="img2.jpg" width="100%" />
		</div>
		<h2>The Todd-Coxeter Algorithm</h2>

		<p>
			Our example relations above form a special group, called a Coxeter group. That is a group where the generators have relations
			of the form: \((ab)^{m_{ab}}\), as above: $$(RG)^4 = (GB)^3 = (RB)^2$$ The generators must also be their own inverse:
			$$R^2 = B^2 = G^2$$ Since the generators are their own inverses, they can be associated with reflections.
		</p>

		<p>
			For Coxeter groups, it is possible to identify all elements in the group, given the generators. The
			<a href="https://en.wikipedia.org/wiki/Todd%E2%80%93Coxeter_algorithm">Todd-Coxeter Algorithm</a> provides a way to identify and count all elements generated by our generators.
			(Quick digression: The Todd-Coxeter algorithm might be the first non-numerical algorithm to be implemented on a digital computer - using an
					<a href="https://www.cambridge.org/core/journals/mathematical-proceedings-of-the-cambridge-philosophical-society/article/coset-enumeration-on-digital-computers/047323FB9415ACF3466E627590ABB790">
						EDSAC 1 in 1953</a>)
		</p>
		<p>Actually, the Todd-Coxeter algorithm does a bit more than counting the elements: it also allows for enumerating all <b>cosets</b> of G, for a given subgroup H. </p>
		<p>What does this mean?</p>
		<p>
			A coset is the set resulting from multiplying all members in \(H\) by a group element \(g\) from \(G\). A (left) coset is written
			\(gH\). The number of cosets is written \(|G:H|\). Lagrange's theorem states that \( [G:H]={|G| \over |H|} \). All the cosets
			for a given subgroup form a new set, called a
			<b>quotient set</b> (denoted G/H).
		</p>
	
		<p>The algorithm works by keeping track of several tables: a coset table (listing the generator actions on the different cosets),
			a subgroup table (listing subgroup generator actions), and a table for each relation between the group generators. The
			algorithm works by filling out rows in these tables. Once a row is closed, a (potentially) new piece of information is
			known.
		</p>
		<p> Here is a demo (use the 'step' button to fill the table):
		</p>
		<div class="fullwidth" id="coxeterDemo">
			<p>
				Group:
				<select class="fancy" onchange="updateToddCoxeter()" id="s1" style="width: 350px">
					<option>rgrgrg,gbgbgb,rbrb (tetrahedron)</option>
					<option selected="selected">rgrgrgrg,gbgbgb,rbrb (cube)</option>
					<option>rgrgrg,gbgbgbgb,rbrb (octa)</option>
					<option>rgrgrgrgrg,gbgbgb,rbrb (dodecahedron)</option>
					<option>rgrgrg,gbgbgbgbgb,rbrb (icosahedron)</option>
				</select>
				Subgroup:
				<select class="fancy" onchange="updateToddCoxeter()" id="s2" style="width: 150px">
					<option>none</option>
					<option>r,g</option>
					<option>g,b</option>
					<option selected="selected">r,b</option>
				</select>
				<a href="javascript:doStep()" class="interactive">Step</a>

				<div id="output"></div>

				<script>

					var tcStep;
					var doIteration;
					var iter = 0;

					function doStep() {
						if (tcStep == undefined) {
							tcStep = getTC();
							doIteration = tcStep.initSolver();
							iter = 0;
						}
						if (!doIteration()) {
							var d = document.getElementById("output");
							d.innerHTML = "<p>Number of cosets:" + tcStep.cosetTable.rows.length + "</p>" + tcStep.getTables();
							tcStep = undefined; // reset

							return;
						}
						var d = document.getElementById("output");
						d.innerHTML = "<p><b>In progress (step " + (++iter) + ")</b><p>" + tcStep.getTables();
					}

					function getTC() {
						var e = document.getElementById("s1");
						var group = e.options[e.selectedIndex].value.split(" ")[0];

						var e = document.getElementById("s2");
						var subgroup = e.options[e.selectedIndex].value;
						if (subgroup == "none") subgroup = undefined;

						var tc = new ToddCoxeter(group, subgroup);
						return tc;
					}

					function updateToddCoxeter() {
						tcStep = undefined; // reset
						var tc = getTC();
						tc.solve();
						var d = document.getElementById("output");
						d.innerHTML = "<p>Number of cosets:" + tc.getCosetCounts() + "<p>" + tc.getTables();
					}

					updateToddCoxeter();
				</script>
		</div>

		<p>Let us look at the various cosets you get when you use Todd-Coxeter on the symmetry groups for the regular polytopes, using different subsets of
			the generators to specify a subgroup:</p>
		<div class="fullwidth">

			<table class="blueTable inlineCoxeter">
				<thead>
					<tr>
						<th colspan=4 style="visibility: hidden; border: 0px"></th>
						<th colspan=3>Subgroup cosets</th>
					</tr>
				</thead>
				<thead>
					<tr>
						<th>Name</th>
						<th>Diagram</th>
						<th>Generator relations</th>
						<th>Automorphisms</th>
						<th>g,b</th>
						<th>r,b</th>
						<th>r,g</th>
					</tr>
				</thead>
				<tbody>
					<tr>
						<td>Tetrahedron</td>
						<td>COX(3,3)</td>
						<td>\((rg)^3\),\((gb)^3\);\((rb)^2\)</td>
						<td>24</td>
						<td>4</td>
						<td>6</td>
						<td>4</td>
					</tr>
					<tr>
						<td>Cube</td>
						<td>COX(4,3)</td>
						<td>\((rg)^4\),\((gb)^3\),\((rb)^2\)</td>
						<td>48</td>
						<td>8</td>
						<td>12</td>
						<td>6</td>
					</tr>
					<tr>
						<td>Octahedron</td>
						<td>COX(3,4)</td>
						<td>\((rg)^3\),\((gb)^4\),\((rb)^2\)</td>
						<td>48</td>
						<td>6</td>
						<td>12</td>
						<td>8</td>
					</tr>
					<tr>
						<td>Dodecahedron</td>
						<td>COX(5,3)</td>
						<td>\((rg)^5\),\((gb)^3\),\((rb)^2\)</td>
						<td>120</td>
						<td>20</td>
						<td>30</td>
						<td>12</td>
					</tr>
					<tr>
						<td>Icosahedron</td>
						<td>COX(3,5)</td>
						<td>\((rg)^3\),\((gb)^5\),\((rb)^2\)</td>
						<td>120</td>
						<td>12</td>
						<td>30</td>
						<td>20</td>
					</tr>
					<tr>
						<th colspan=4 style="visibility: hidden;  border: 0px"></th>
						<th>Vertices</th>
						<th>Edges</th>
						<th>Faces</th>
					</tr>
				</tbody>
			</table>

			<table class="blueTable inlineCoxeter">
				<thead>
					<tr>
						<th colspan=4 style="visibility: hidden; border: 0px"></th>
						<th colspan=4>Subgroup cosets</th>
					</tr>
				</thead>
				<thead>
					<tr>
						<th>Name</th>
						<th>Diagrams</th>
						<th>Generator relations</th>
						<th>Automorphisms</th>
						<th>g,b,a</th>
						<th>r,b,a</th>
						<th>r,g,a</th>
						<th>r,g,b</th>
					</tr>
				</thead>
				<tbody>
					<tr>
						<td>5-cell</td>
						<td>COX(3,3,3)</td>
						<td>\((rg)^3\),\((gb)^3\),\((ba)^3\),\((rb)^2\),\((ra)^2\),\((ga)^2\)</td>
						<td>120</td>
						<td>5</td>
						<td>10</td>
						<td>10</td>
						<td>5</td>
					</tr>
					<tr>
						<td>8-cell</td>
						<td>COX(4,3,3)</td>
						<td>\((rg)^4\),\((gb)^3\),\((ba)^3\),\((rb)^2\),\((ra)^2\),\((ga)^2\)</td>
						<td>384</td>
						<td>16</td>
						<td>32</td>
						<td>24</td>
						<td>8</td>
					</tr>
					<tr>
						<td>16-cell</td>
						<td>COX(3,3,4)</td>
						<td>\((rg)^3\),\((gb)^3\),\((ba)^4\),\((rb)^2\),\((ra)^2\),\((ga)^2\)</td>
						<td>384</td>
						<td>8</td>
						<td>24</td>
						<td>32</td>
						<td>16</td>
					</tr>
					<tr>
						<td>24-cell</td>
						<td>COX(3,4,3)</td>
						<td>\((rg)^3\),\((gb)^4\),\((ba)^3\),\((rb)^2\),\((ra)^2\),\((ga)^2\)</td>
						<td>1152</td>
						<td>24</td>
						<td>96</td>
						<td>96</td>
						<td>24</td>
					</tr>
					<tr>
						<td>120-cell</td>
						<td>COX(5,3,3)</td>
						<td>\((rg)^5\),\((gb)^3\),\((ba)^3\),\((rb)^2\),\((ra)^2\),\((ga)^2\)</td>
						<td>14400</td>
						<td>600</td>
						<td>1200</td>
						<td>720</td>
						<td>120</td>
					</tr>
					<tr>
						<td>600-cell</td>
						<td>COX(3,3,5)</td>
						<td>\((rg)^3\),\((gb)^3\),\((ba)^5\),\((rb)^2\),\((ra)^2\),\((ga)^2\)</td>
						<td>14400</td>
						<td>120</td>
						<td>720</td>
						<td>1200</td>
						<td>600</td>
					</tr>
					<tr>
						<th colspan=4 style="visibility: hidden;  border: 0px"></th>
						<th>Vertices</th>
						<th>Edges</th>
						<th>Faces</th>
						<th>Cells</th>
					</tr>
				</tbody>
			</table>
		</div>
		<script>
			var tables = document.getElementsByClassName("inlineCoxeter");
			for (var t = 0, table; table = tables[t]; t++)
				for (var i = 0, row; row = table.rows[i]; i++) {
					for (var j = 0, c; c = row.cells[j]; j++) {
						if (c.innerText && c.innerText.indexOf("COX") != -1) {

							var reg = /COX\((.*)\)/g;
							var match = reg.exec(c.innerText);
							c.innerText = "";
							insertCoxeter(c, match[1].split(","));
						}
					}
				}
		</script>

		<p>An interesting structure emerges here: looking at the cosets for the subgroups generated by leaving out one of the generators,
			<em>the number of cosets</em> matches the number of vertices, edges, or faces! It seems we can fully describe the geometric
			structure by forming various quotient sets.</p>
		<p>
			Also notice, that the ordering matter here: the cube and octahedron have the same generators (just switch 'r' and 'b'), and
			same symmetry group, but the number of faces and vertices are swapped. These shapes are said to be
			<b>dual</b>. The Dodecahedron/Icosahedron, the 8-cell/16-cell, and 120-cell/600-cell all form dual pairs.
			
			</p><p>
			So what differentiates
			a cube from an octahedron? The answer is, that it depends on how the initial vertex is placed. Notice the outer circle
			on the first reflector, r, in the Coxeter diagram: this circle specifies that the initial vertex should be placed somewhere
			<em>off</em> the reflection plane for r, but on the reflection planes for g and b. (This also means that the initial
			vertex would be taken to itself when applying g and b). 
		</p>
		<p>
			Let us explore the quotient sets a bit more: how do we generate the geometry and how do we associate edges with vertices?
		</p>
		<div class="fullwidth">
			<img src="img1.jpg" width="100%" />
		</div>

		<h2>Generating geometry from group structure</h2>
		<p>
			We will recreate the Euclidean geometry from the abstract Coxeter group description.
		</p>
		<p>
			Given the generator relations, we know the angles between the reflector planes: If there is a relation on the form: \(RB^{N}\),
			the angle between the reflection planes R and B must be \( \pi / N \) - which again corresponds to a rotation of \( 2\pi / N \) degrees.
			For the cube the angles between the reflection planes are 45, 60, and 90. The first
			step is to create a set of reflection plane normal vectors with these angles between them. 
			This can be done iteratively, by starting with an arbitrary
			unit vector, and adding vectors at corresponding angles, e.g.:

		</p>
		<p>
			$$ \begin{pmatrix} & 1 \\ & 0 \\ & 0 \end{pmatrix}, \begin{pmatrix} & cos(\theta_{12}) \\ & N_1 \\ & 0 \end{pmatrix}, \begin{pmatrix}
			& cos(\theta_{13}) \\ & \frac{cos(\theta_{23})-cos(\theta_{12})cos(\theta_{13}) }{N_1} \\ & N_2 \end{pmatrix} $$
		</p>
		<p>These vectors are the normals of the reflecting planes (The N's are normalization constants that can be trivially
			calculated - all the normals must be unit length).</p>
		<p>
			We now have our reflection planes (the group generators) defined. Given a starting point, we can apply these and create the full geometry.
			But how do we choose the starting point? As previously mentioned the cube and octahedron share the same generator relations
			(they are dual). So why are they different? Looking at their coxeter diagram in the table above, this has to do with the
			special outer circle. This outer circle has a special meaning: the initial starting point should be located on the two
			other reflection planes (the blue and the green), but not on the red one.</p>
		<p>
			We can use
			<a href="http://mathworld.wolfram.com/Gram-SchmidtOrthonormalization.html">Gram-Schmidt orthonormalization</a> to create a vector that is contained 
			in the blue and the green plane, but not in the
			red plane. We do this by starting out with the three reflection plane normal vectors in the order blue, green, and red. After applying Gram-Schmidt
			to this set of vectors, the last vector in the transformed set will be orthogonal to the blue and green reflection plane
			normal vectors (and thus be located on the intersection of these two planes).
		</p>
		<p>The example below shows how this works for the dodecahedron. Like the cube, the dedocahedron can be generated by three generators,
			 with angles 36, 60, and 90 degrees between the reflecting planes.</p>
		<div class="fullwidth" id="largeContainer">
			<script>
				function dumpTable(tc) {
					var table = tc.cosetTable;
					var genSymbols = tc.rels.generators;

					var mapper = function (e) { return self.rels.generators[e]; };
					var s = '<div id="table-scroll" style="vertical-align: top; height: 600px">';

					s += "<table class='blueTable' style='height: 600px' id='mainTable'><thead><th></th><th>Element</th>";
					for (var i = 0; i < table.genList.length; i++) {
						s += "<th>" + genSymbols[table.genList[i]] + "</th>";
					}
					if (table.extraColumns) {
						for (var i = 0; i < table.extraColumns.length; i++) {
							s += "<th> " + table.extraColumnNames[i][0] + "</th>";
						}
					}
					s += "</thead>";
					for (var i = 0; i < table.rows.length; i++) {
						s += "<tr><td>" + table.rowCosets[i] + "</td>";
						var el = tc.getRepresentiveString(tc.getRepresentiveForCoset(i));
						s += "<td>" + (el == "" ? "I" : el) + "</td>";

						for (var j = 0; j < table.genList.length; j++) {
							var o = table.rows[i][j];
							s += "<td>" + (o == undefined ? "" : o) + "</td>";
						}
						if (table.extraColumns) {
							for (var j = 0; j < table.extraColumns.length; j++) {
								s += "<td><a class='interactive' onmouseover='selectRow(" + j + "," + i + ")' onmouseout='selectRow(" + j + ")'>" + table.extraColumnNames[j][1] + table.extraColumns[j][i] + "</a></td>";
							}
						}
						s += "</tr>";
					}
					s += "</table></div>";
					return s;
				};

				var freeGroup = getCoxeterGroup(5, 3, 2);

				// Find vertices
				function getVertixMatrices(vertexOperators, reflectionMatrices) {
					var ms = new Array(vertexOperators.length);
					for (var i = 0; i < vertexOperators.length; i++) {
						var operatorList = vertexOperators[i];

						var m = new THREE.Matrix3();
						for (var j = 0; j < operatorList.length; j++) {
							m.premultiply(reflectionMatrices[operatorList[j]]);
						}
						ms[i] = m;
					}
					return ms;
				}

				var container = document.createElement('span');
				document.getElementById("largeContainer").appendChild(container);

				container.innerHTML += dumpTable(freeGroup);
			</script>
			<script>
				var setInitialVertex;
				values = {};
				var cayley;
				var structure = freeGroup.getStructure();

				function createOrtho(v1) {
					var v2;
					if (v1.x == 0 && v1.y == 0) {
						v2 = new THREE.Vector3(1, 0, 0);
					} else {
						v2 = new THREE.Vector3(v1.y, -v1.x, 0); v2.normalize();
					}
					return [v2, new THREE.Vector3().crossVectors(v1, v2).normalize()];
				}

				function init() {
					var container = document.createElement('div');
					container.style.display = "inline";
					document.getElementById("largeContainer").appendChild(container);

					var scene = getStandard3DView(container, 600, 600);
					var nG;
					var nB;
					var nR;

					var a12 = Math.PI / freeGroup.powers[0];
					var a23 = Math.PI / freeGroup.powers[1];
					var a13 = Math.PI / freeGroup.powers[2];

					nR = new THREE.Vector3(1, 0, 0);
					nG = new THREE.Vector3(Math.cos(a12), Math.sqrt(1 - Math.cos(a12) * Math.cos(a12)), 0);
					var nb1 = Math.cos(a13);
					var nb2 = (Math.cos(a23) - nG.x * nb1) / nG.y;
					var nb3 = Math.sqrt(1 - nb1 * nb1 - nb2 * nb2);

					nB = new THREE.Vector3(nb1, nb2, nb3);
					var O = new THREE.Vector3(0, 0, 0);

					var frame = [];
					var orthoFrame = createOrtho(nR);
					var obj = createOrigoPlane(orthoFrame[0], orthoFrame[1], 0xff0000);
					scene.add(obj); frame.push(obj);

					scene.add(obj); frame.push(obj);
					orthoFrame = createOrtho(nG);
					obj = createOrigoPlane(orthoFrame[0], orthoFrame[1], 0x00ff00);
					scene.add(obj); frame.push(obj);

					orthoFrame = createOrtho(nB);
					obj = createOrigoPlane(orthoFrame[0], orthoFrame[1], 0x0000ff);
					scene.add(obj); frame.push(obj);

					var nBp = gramSchmidt([nG, nR, nB])[2];
					var nRp = gramSchmidt([nB, nG, nR])[2];
					var nGp = gramSchmidt([nR, nB, nG])[2];
					if (nRp.dot(nBp) < 0) nRp.multiplyScalar(-1);
					if (nGp.dot(nBp) < 0) nGp.multiplyScalar(-1);

					var w = 0.01;
					var arrowWidth = 0.03;
					var arrowLength = 0.1;

					obj = createLine(O, nGp.clone().multiplyScalar(2.0), w, 0x00ff00, arrowWidth, arrowLength);
					scene.add(obj); frame.push(obj);
					obj = createLine(O, nBp.clone().multiplyScalar(2.0), w, 0x0000ff, arrowWidth, arrowLength);
					scene.add(obj); frame.push(obj);
					obj = createLine(O, nRp.clone().multiplyScalar(2.0), w, 0xff0000, arrowWidth, arrowLength);
					scene.add(obj); frame.push(obj);

					// Get vertices
					var reflectionMatrices = [];
					reflectionMatrices.push(getReflectionMatrix(nR.x, nR.y, nR.z));
					reflectionMatrices.push(getReflectionMatrix(nG.x, nG.y, nG.z));
					reflectionMatrices.push(getReflectionMatrix(nB.x, nB.y, nB.z));

					var ms = getVertixMatrices(structure.vertexOperators, reflectionMatrices);

					var spheres = [];
					var cayley = [];
					cayley.clear = function () {
						var a;
						while (a = cayley.pop()) {
							scene.remove(a);
							a.geometry.dispose();
						}
					}

					showCayley = function (generators) {
						cayley.clear();

						if (generators == undefined) {
							frame.forEach(function (e) { e.visible = true; });
							scene.doRender();
							return;
						}
						frame.forEach(function (e) { e.visible = false; });

						var posX = spheres[0].position.clone();
						var m = THREE.matrix3;
						var prev;

						var colors = [0xff0000, 0x00ff00, 0x0000ff];

						for (var i = -1; i < generators.length; i++) {

							if (i != -1) {
								posX.applyMatrix3(reflectionMatrices[generators[i]]);
							}

							if (i == generators.length - 1) {
								var geometry = new THREE.SphereGeometry(0.05, 32, 32);
								var material = new THREE.MeshStandardMaterial({ color: 0x000000 });
								var sphere = new THREE.Mesh(geometry, material);
								sphere.position.copy(posX);
								scene.add(sphere);
								cayley.push(sphere);
							}

							if (prev != undefined) {
								var arrowWidth = 0.06;
								var arrowLength = 0.2;

								var s = createLine(prev, posX, 0.022, colors[generators[i]], arrowWidth, arrowLength);
								if (s != undefined) {
									scene.add(s);
									cayley.push(s);
								}
							}
							prev = posX.clone();

							scene.doRender();
						}
					}

					showEdge = function (edge) {
						cayley.clear();

						if (edge == undefined) {
							frame.forEach(function (e) { e.visible = true; });
							scene.doRender();
							return;
						}
						frame.forEach(function (e) { e.visible = false; });

						var arrowWidth = 0.06;
						var arrowLength = 0.2;

						var s = createLine(spheres[edge[0]].position, spheres[edge[1]].position, 0.022, 0x000000, arrowWidth, arrowLength);
						cayley.push(s);
						scene.add(s);
						s = createLine(spheres[edge[1]].position, spheres[edge[0]].position, 0.022, 0x000000, arrowWidth, arrowLength);
						cayley.push(s);
						scene.add(s);
						scene.doRender();
					}

					showFace = function (face, edgeList) {
						cayley.clear();

						if (face == undefined) {
							frame.forEach(function (e) { e.visible = true; });
							scene.doRender();
							return;
						}
						frame.forEach(function (e) { e.visible = false; });

						var arrowWidth = 0.06;
						var arrowLength = 0.2;


						for (var i = 0; i < face.length; i++) {
							var edge = edgeList[face[i]];
							var s = createLine(spheres[edge[0]].position, spheres[edge[1]].position, 0.022, 0x000000);
							cayley.push(s);
							scene.add(s);
							s = createLine(spheres[edge[1]].position, spheres[edge[0]].position, 0.022, 0x000000);
							cayley.push(s);
							scene.add(s);
						}

						scene.doRender();
					}

					setInitialVertex = function (v1, v2, v3) {
						var pos = new THREE.Vector3(0, 0, 0);
						pos.addScaledVector(nRp, v1);
						pos.addScaledVector(nGp, v2);
						pos.addScaledVector(nBp, v3);

						for (var i = 0; i < spheres.length; i++) {
							scene.remove(spheres[i]);
							spheres[i].geometry.dispose();
						}
						spheres = [];

						for (var i = 0; i < ms.length; i++) {
							var geometry = new THREE.SphereGeometry(0.034, 32, 32);
							var material = new THREE.MeshStandardMaterial({ color: (i != 0 ? 0xffffff : 0x000000) });
							var sphere = new THREE.Mesh(geometry, material);
							sphere.position.copy(pos.clone().applyMatrix3(ms[i]));
							scene.add(sphere);
							spheres.push(sphere);

						}

						for (var i = 0; i < structure.edgeList.length; i++) {
							var v1 = structure.edgeList[i][0];
							var v2 = structure.edgeList[i][1];
							var s = createLine(spheres[v1].position, spheres[v2].position, 0.02, 0xffffff);
							if (s != undefined) {
								scene.add(s);
								spheres.push(s);
							}
						}

						scene.doRender();
					}

					setInitialVertex(1, 0, 0);
				}

				init();


				function selectRow(col, r) {
					var table = document.getElementById("mainTable");

					var ct = freeGroup.cosetTable;
					var selected = (col == undefined ? -1 : ct.extraColumns[col][r]);

					for (var i = 1, row; row = table.rows[i]; i++) {
						var val = ct.extraColumns[col][i - 1];
						row.className = (val == selected ? "highlight" : "");
					}

					if (col == 0) {
						showCayley(ct.reps[r]);
					} else
						if (col == 1) {
							var edge = ct.extraColumns[col][r];
							showEdge(structure.edgeList[edge]);
						} else
							if (col == 2) {
								var face = ct.extraColumns[col][r];
								showFace(structure.faceList[face], structure.edgeList);
							}
				}
			</script>

		</div>
		<p>
			The table can be used to explore how the different quotient sets ties the vertices, edges, and faces together. Try hovering an entry.
		</p>
		<p>
			For instance, see how vertex
			<a class='interactive' onmouseover='selectRow(0,0)' onmouseout='selectRow(0)'>V0</a> connects to three edges (E0,E1,E3) and three faces (F0,F1,F2). Likewise, edge
			<a class='interactive' onmouseover='selectRow(1,0)' onmouseout='selectRow(0)'>E0</a> connects two vertices (V0,V1) and two faces (F0, F1). The face
			<a class='interactive' onmouseover='selectRow(2,0)' onmouseout='selectRow(0)'>F0</a> connects five vertices (V0,V1,V2,V3,V5) and five edges (E0,E1,E2,E4,E6)
		</p>
		<p>Also notice the volume enclosed by the three arrows. This is the
			<b>fundamental domain</b>, which will we return to in the next section.</p>

		<div class="fullwidth">
			<img src="img4.jpg" width="100%" />
		</div>
		<h2>Ray tracing reflection groups</h2>
		<p>I have long been a fan of ray marching, and
			<a href="http://blog.hvidtfeldts.net/index.php/2011/06/distance-estimated-3d-fractals-part-i/">distance estimation techniques</a>.
		</p>
		<p>
			The previous section showed how to construct geometry by explicitly calculating positions for vertices, edges, and faces, and then displaying
			the structures by rasterizing polygons (using WebGL).
		</p>
		<p>
			But it is possible to construct very efficient distance estimators for the reflection group polytopes - including the four-dimensional
			ones. Utilizing modern GPUs, this makes it possible to ray trace high-quality images in real-time.
		</p>
		<p>
			This technique was originally described by Knighty in this
			<a href="http://www.fractalforums.com/fragmentarium/solids-many-many-solids/">Fractal Forums thread</a> from 2012.
		</p>
		<p>The basic idea is a clever trick: instead of trying to calculate the positions of all vertices and edges, we will
			first transform (using the group reflections) all points in space into the same 'fundamental' region or domain. 
			The basic building block will be a
			<b>fold</b>: a simple conditional reflection - if we are on the wrong side of a reflection plane, we will do the reflection
			- otherwise not. Once our paths of folds ends in the fundamental domain, we can quickly test whether we are inside a vertex, edge, or plane (at
			least after assigning a width to these objects). We can also calculate the distance to the nearest part of the structure
			this way.
		</p>
		<p>
			Being able to calculate the distance to the nearest part of a structure is very powerful. Given this
			<b>distance estimator</b>, we can render our object using
			<b>ray marching</b>: we can take steps along a ray from the camera, and stop once we are sufficiently close to the object.
			The distance estimator tells us how large steps we are allowed to march. And, since we now know how to determine how an
			arbitrary ray intersects our structure, we can ray trace it, including shadows and reflections. I previously described the technique
			<a href="http://blog.hvidtfeldts.net/index.php/2011/08/distance-estimated-3d-fractals-iii-folding-space/">here</a> for a recursive tetrahedron.
		</p>
	

		<div class="fullwidth" id="distanceContainer"></div>

		<script>
			var setDistancePoint;
			var structure = freeGroup.getStructure();


			var domainCenter;
			function init() {
				var container = document.createElement('div');
				container.style.display = "inline";
				document.getElementById("distanceContainer").appendChild(container);

				var scene = getStandard3DView(container, 600, 600);
				var nG;
				var nB;
				var nR;

				var a12 = Math.PI / freeGroup.powers[0];
				var a23 = Math.PI / freeGroup.powers[1];
				var a13 = Math.PI / freeGroup.powers[2];

				nR = new THREE.Vector3(1, 0, 0);
				nG = new THREE.Vector3(Math.cos(a12), Math.sqrt(1 - Math.cos(a12) * Math.cos(a12)), 0);
				var nb1 = Math.cos(a13);
				var nb2 = (Math.cos(a23) - nG.x * nb1) / nG.y;
				var nb3 = Math.sqrt(1 - nb1 * nb1 - nb2 * nb2);
				nB = new THREE.Vector3(nb1, nb2, nb3);

				var O = new THREE.Vector3(0, 0, 0);

				var frame = [];
				var orthoFrame = createOrtho(nR);
				var obj = createOrigoPlane(orthoFrame[0], orthoFrame[1], 0xff0000);
				scene.add(obj); frame.push(obj);

				scene.add(obj); frame.push(obj);
				orthoFrame = createOrtho(nG);
				obj = createOrigoPlane(orthoFrame[0], orthoFrame[1], 0x00ff00);
				scene.add(obj); frame.push(obj);

				orthoFrame = createOrtho(nB);
				obj = createOrigoPlane(orthoFrame[0], orthoFrame[1], 0x0000ff);
				scene.add(obj); frame.push(obj);

				var nBp = gramSchmidt([nG, nR, nB])[2];
				var nRp = gramSchmidt([nB, nG, nR])[2];
				var nGp = gramSchmidt([nR, nB, nG])[2];
				if (nRp.dot(nBp) < 0) nRp.multiplyScalar(-1);
				if (nGp.dot(nBp) < 0) nGp.multiplyScalar(-1);

				domainCenter = new THREE.Vector3((nBp.x + nRp.x + nGp.x) / 3.0, (nBp.y + nRp.y + nGp.y) / 3.0, (nBp.z + nRp.z + nGp.z) / 3.0);

				nR.multiplyScalar(-1.0);
				nB.multiplyScalar(-1.0);

				var w = 0.01;
				var arrowWidth = 0.03;
				var arrowLength = 0.1;

				// Get vertices
				var reflectionMatrices = [];
				reflectionMatrices.push(getReflectionMatrix(nR.x, nR.y, nR.z));
				reflectionMatrices.push(getReflectionMatrix(nG.x, nG.y, nG.z));
				reflectionMatrices.push(getReflectionMatrix(nB.x, nB.y, nB.z));

				var ms = getVertixMatrices(structure.vertexOperators, reflectionMatrices);

				var sceneObjects = [];
				sceneObjects.clear = function () {
					var a;
					while (a = sceneObjects.pop()) {
						scene.remove(a);
						a.geometry.dispose();
					}
				}

				setDistancePoint = function (vx, vy, vz) {
					var pos = nRp;
					var colors = [0xff0000, 0x00ff00, 0x0000ff];

					sceneObjects.clear();
					var reflectors = [nR, nG, nB];

					for (var i = 0; i < ms.length; i++) {
						var geometry = new THREE.SphereGeometry(0.034, 32, 32);
						var material = new THREE.MeshStandardMaterial({ color: 0xffffff });
						var sphere = new THREE.Mesh(geometry, material);
						sphere.position.copy(pos.clone().applyMatrix3(ms[i]));
						scene.add(sphere);
						sceneObjects.push(sphere);
					}

					for (var i = 0; i < structure.edgeList.length; i++) {
						var v1 = structure.edgeList[i][0];
						var v2 = structure.edgeList[i][1];
						var s = createLine(sceneObjects[v1].position, sceneObjects[v2].position, 0.02, 0xffffff);
						if (s != undefined) {
							scene.add(s);
							sceneObjects.push(s);
						}
					}

					var prev;
					var pos = new THREE.Vector3(vx, vy, vz);
					var fold = 0;

					var geometry = new THREE.SphereGeometry(0.034, 8, 8);
					var material = new THREE.MeshStandardMaterial({ color: 0xff0000 });
					var sphere = new THREE.Mesh(geometry, material);
					sphere.position.copy(pos);
					scene.add(sphere);
					sceneObjects.push(sphere);

					for (var i = 0; i < 15; i++) {
						// Fold
						var r = reflectors[i % 3];
						var dot = pos.dot(r);
						if (dot > 0) {
							fold++;
							prev = pos.clone();
							pos.sub(r.clone().multiplyScalar(dot * 2.0));

							var arrowWidth = 0.02;
							var arrowLength = 0.02;
							var s = createLine(prev, pos, 0.006, colors[i % 3], arrowWidth, arrowLength);
							if (s != undefined) {
								scene.add(s);
								sceneObjects.push(s);
							}
						}
					}
					var dist = nRp.distanceTo(pos);
					var geometry = new THREE.SphereGeometry(dist, 28, 28);
					var material = new THREE.MeshStandardMaterial({ color: 0xff0000, opacity: 0.5, transparent: true });
					var sphere = new THREE.Mesh(geometry, material);
					sphere.position.copy(new THREE.Vector3(vx, vy, vz));
					scene.add(sphere);
					sceneObjects.push(sphere);

					var geometry = new THREE.SphereGeometry(0.034, 8, 8);
					var material = new THREE.MeshStandardMaterial({ color: 0xffffff });
					var sphere = new THREE.Mesh(geometry, material);
					sphere.position.copy(pos.clone());
					scene.add(sphere);
					sceneObjects.push(sphere);

					var s = createLine(nRp, pos, 0.002, 0xffffff);
					if (s != undefined) {
						scene.add(s);
						sceneObjects.push(s);
					}

					scene.doRender();
				}

				setDistancePoint(0.5, 0, 0);
			}

			init();

			var distanceGUI = new dat.GUI({ autoPlace: false });

			var distanceDemoContainer = document.createElement('div');
			distanceDemoContainer.style.width = "300px";
			distanceDemoContainer.style.display = "inline";
			distanceDemoContainer.style.position = "absolute";
			distanceDemoContainer.style.whitespace = "nowrap";

			distanceDemoContainer.appendChild(distanceGUI.domElement);
			document.getElementById("distanceContainer").appendChild(distanceDemoContainer);
			var f = distanceGUI.addFolder("Position");
			f.open();
			var pp = {
				x: 0.5,
				y: 0.1,
				z: 0.1,
			};

			f.add(pp, "x", -1.0, 1.0).name("x").onChange(function (v) {
				setDistancePoint(pp.x, pp.y, pp.z);
			}).listen();
			f.add(pp, "y", -1.0, 1.0).name("y").onChange(function (v) {
				setDistancePoint(pp.x, pp.y, pp.z);
			}).listen();
			f.add(pp, "z", -1.0, 1.0).name("z").onChange(function (v) {
				setDistancePoint(pp.x, pp.y, pp.z);
			}).listen();

			// The longest path
			function setToOpposite() {
				pp.x = domainCenter.x * -1;
				pp.y = domainCenter.y * -1;
				pp.z = domainCenter.z * -1;
				setDistancePoint(pp.x, pp.y, pp.z);
			}

			// A point on our domain
			function setToDomain() {
				pp.x = domainCenter.x;
				pp.y = domainCenter.y;
				pp.z = domainCenter.z;
				setDistancePoint(pp.x, pp.y, pp.z);
			}
		</script>
		<p>
			The illustration above shows how to fold a point in space (the red ball) back into the fundamental domain 
			(<a href="javascript:setToDomain()" class="interactive">move to this region</a>). You can move the red ball using the controls. 
			By repeatedly applying the folds, we can trace a piecewise linear path
			back to the fundamental domain (the white ball shows the end point in the fundamental domain). Once in the fundamental
			domain, we can calculate the distance to the initial vertex: this distance is shown by the thin white line. 
			<em>Due to the symmetries, this is the same as the distance to the
			closest vertex of the red ball!</em> The distance is visualized as the radius of the red sphere centered on the red ball.
		</p>
		<p>
			How many folds do we need? It seems like the worst case is when the point is located in "mirrored" fundamental domain 
			(<a href="javascript:setToOpposite()" class="interactive">move to this region</a>). In this domain, 15 folds (3 generators x the max symmetry of 5) are required.</p>
		<p>
			It may not seem the advantage is that big: we could have explicitly calculated the 20 vertices and 30 edges and calculated
			the distances to those. But for more complex structures (the 120-cell has 600 vertices and 1200 edges), the advantage
			is huge: the number of regions that can be folded back into a fundamental domain grows exponentially with the number of
			fold operations. And fold operations are cheap: for instance, in the example above, two of the reflections are orthogonal
			and can be aligned with the coordinate system axes. In that case, the fold operation may be implemented simply by taking
			the absolute value of the coordinates, e.g. pos.xy = abs(pos.xy). A very fast operation!
		</p>
		<p>The folding approach also has another advantage: we do not require the elaborate coset structure of the symmetry group
			to figure out how the vertices are organized into edges and faces. We only need to describe the fundamental domain, then
			symmetry will take care of the rest.
		</p>





		<p>
			Now we are ready for a real example of ray tracing a system of three generators:
		</p>
		<div class="rightBox" id="datGui1">
			Diagram: <span id="coxeter"></span>
		</div>
	
	
		<script>
			
			var gui = new dat.GUI({ autoPlace: false });
			var staticContainer = document.getElementById("datGui1");
			staticContainer.appendChild(gui.domElement);

			var containerZ = document.createElement('div');
			containerZ.style.display = "inline";
			document.getElementById("main").appendChild(containerZ);
			var polyhedronScene;

			containerZ.innerHTML = "<span style='width: 650px; height: 700px'><img src='inactive2.png' onclick='initializePolyhedron()'></span>";

			function getModification(number) {
				var names = ["Undefined", "Regular", "Rectified", "Truncated", "Dual", "Cantellated", "Bitruncated", "Cantitruncated"];
				return names[number];
			}
			function getBasicForm(degree) {
				var form = ["","","","Tetrahedron", "Cube", "Dodecahedron"];
				return form[degree];
			}

			var initializePolyhedron = function () {
				containerZ.innerHTML = "";
				loadFiles(['vertex.glsl', 'polyhedron.glsl', 'simpleRaymarcher.glsl'], function (s) {
					polyhedronScene = createFragmentShader(containerZ, 650, 700, s[0], s[1] + s[2], gui);
					polyhedronScene.addUniformsChangedListener( function() {
						document.getElementById("coxeter").innerHTML = "";
						var active = [polyhedronScene.params["U"]>0,polyhedronScene.params["V"]>0,polyhedronScene.params["W"]>0];
						insertCoxeter(document.getElementById("coxeter"), [polyhedronScene.params["Degree"],3],active);
						var name = getModification(
							(polyhedronScene.params["U"]>0 ? 1 : 0)+
							(polyhedronScene.params["V"]>0 ? 2 : 0)+
							(polyhedronScene.params["W"]>0 ? 4 : 0));
						document.getElementById("coxeter").innerHTML += name + "&nbsp;" + getBasicForm(polyhedronScene.params["Degree"]);
						
					});

					polyhedronScene.params.default = "Dodecahedron";
					gui.add(polyhedronScene.params, 'default', ["Tetrahedron", "Cube", "Octahedron", "Dodecahedron", "Icosahedron"]).name("Preset").onChange(function (v) {
						function set(name, val) {
							polyhedronScene.params[name] = val;
							polyhedronScene.uniforms[name] = { value: val };
						}

						if (polyhedronScene.params.default == "Tetrahedron") {
							set("Degree", 3);
							set("U", 1.0);
							set("V", 0.0);
							set("W", 0.0);
							polyhedronScene.doRender();
						} else if (polyhedronScene.params.default == "Cube") {
							set("Degree", 4);
							set("U", 1.0);
							set("V", 0.0);
							set("W", 0.0);
							polyhedronScene.doRender();
						} else if (polyhedronScene.params.default == "Octahedron") {
							set("Degree", 4);
							set("U", 0.0);
							set("V", 0.0);
							set("W", 1.0);
							polyhedronScene.doRender();
						} else if (polyhedronScene.params.default == "Dodecahedron") {
							set("Degree", 5);
							set("U", 1.0);
							set("V", 0.0);
							set("W", 0.0);
							polyhedronScene.doRender();
						} else if (polyhedronScene.params.default == "Icosahedron") {
							set("Degree", 5);
							set("U", 0.0);
							set("V", 0.0);
							set("W", 1.0);
							polyhedronScene.doRender();
						}
						polyhedronScene.uniformsChanged();
					});
					polyhedronScene.getCamera().position.set(-1, 2, -0.5);
					polyhedronScene.controls.update();
					polyhedronScene.uniformsChanged();
				});
			};
		</script>
		<p>In the example above, the U, V, and W parameters control the position of the initial vertex as specified in a coordinate
			system where each axis lives on the intersection of two reflection planes (the same coordinate system as 
			defined in the dodehedron example with the red, green, and blue arrows - see
			the Gram-Schmidt discussion above).</p>
		<p>The Degree parameter controls one of the angles between the reflection planes (e.g. 3 = 60 degrees, 4 = 45 degrees, 5 = 36
			degrees). The two other angles are always 90 degrees and 60 degrees.</p>
			<p>Notice, that the resulting structures are all convex, but not necessarily regular polytopes.</p>
		<div class="fullwidth">
			<img src="img5.jpg" width="100%" />
		</div>

		<h2>The fourth dimension</h2>
		<p>To get to the fourth dimension, we need one additional trick: the <b>stereographic projection</b>.</p>
		<p>
		</p>

		<div class="rightBox" id="rboxSimple3">
		</div>

		<script>
			function sceneAdd(scene, object, group) {
				if (scene.groupings == undefined) {
					scene.groupings = new Map();
				}
				if (scene.groupings.get(group) == undefined) {
					scene.groupings.set(group, []);
				}
				scene.groupings.get(group).push(object);
				scene.add(object);
			}

			function project(v) {
				// Top is (0,Math.sqrt(3),0) - find line to plane a y=-Math.sqrt(3).
				var dist = (Math.sqrt(3) - v.y) / (2.0 * Math.sqrt(3.0));
				return new THREE.Vector3(v.x / dist, -Math.sqrt(3), v.z / dist);
			}

			var addProjection;

			var gui3 = new dat.GUI({ autoPlace: false });
			var staticContainer3 = document.getElementById("rboxSimple3");
			staticContainer3.appendChild(gui3.domElement);

		
			var f = gui3.addFolder("Rotation");
			f.open();
			var rotationParams = {
				rX: 0,
				rY: 0,
				rZ: 0,
			};

			f.add(rotationParams, "rX", 0, 6.14).name("Rotate X").onChange(function (v) {
				addProjection();
			});
			f.add(rotationParams, "rY", 0, 6.14).name("Rotate Y").onChange(function (v) {
				addProjection();
			});
			f.add(rotationParams, "rZ", 0, 6.14).name("Rotate Z").onChange(function (v) {
				addProjection();
			});
			init();

			function init() {
				var containerX = document.createElement('div');
				containerX.style.display = "inline";
				document.getElementById("main").appendChild(containerX);

				var scene = getStandard3DView(containerX, 650, 700);
				scene.getCamera().position.set(-10, 22, -16);
				scene.getControls().update();

				var v = getVertices();
				var e = getEdges();

				var m = new THREE.MeshStandardMaterial({
					opacity: 0.3,
					transparent: true,
					color: 0x997744,
				});
				var geometry = new THREE.SphereGeometry(Math.sqrt(3), 32, 32);
				var sphere = new THREE.Mesh(geometry, m);
				scene.add(sphere);

				var geometry = new THREE.TorusGeometry(Math.sqrt(3), 0.01, 16, 100);

				var rotObjectMatrix = new THREE.Matrix4();
				rotObjectMatrix.makeRotationAxis(new THREE.Vector3(1, 0, 0), Math.PI / 2.0);

				var material = new THREE.MeshBasicMaterial({ color: 0xffff00 });
				var torus = new THREE.Mesh(geometry, material);

				torus.matrix.multiply(rotObjectMatrix);
				torus.rotation.setFromRotationMatrix(torus.matrix);

				var geometry = new THREE.PlaneGeometry(20, 20, 32);
				var material = new THREE.MeshBasicMaterial({ color: 0xeeeeee, side: THREE.DoubleSide });
				var plane = new THREE.Mesh(geometry, material);
				plane.position.copy(new THREE.Vector3(0, -Math.sqrt(3) - 0.01, 0));
				plane.matrix.multiply(rotObjectMatrix);
				plane.rotation.setFromRotationMatrix(torus.matrix);
				scene.add(plane);

				scene.add(torus);
				scene.groupings = new Map();
				scene.groupings["dynamic"] = [];

				addProjection = function () {
					if (scene.groupings.get("dynamic") !== undefined) {
						scene.groupings.get("dynamic").forEach(function (obj) { scene.remove(obj); obj.geometry.dispose(); obj.material.dispose(); });
						var a = scene.groupings.get("dynamic");
						while (a.length > 0) {
							a.pop();
						}
					}
					var euler = new THREE.Euler(rotationParams.rX, rotationParams.rY, rotationParams.rZ);

					var vv = [];
					for (var i = 0; i < v.length; i++) {
						vv.push(v[i].clone().applyEuler(euler));
					}

					var ee = [];
					for (var i = 0; i < e.length; i++) {
						ee.push(e[i].clone().applyEuler(euler));
					}

					var zenith = new THREE.Vector3(0, Math.sqrt(3), 0);
					spheres = [];
					for (var i = 0; i < vv.length; i++) {
						sceneAdd(scene, createLine(zenith, project(vv[i]), 0.0152, 0xaa0000), "dynamic");
					}

					var divs = 20;
					for (var i = 0; i < ee.length; i += 2) {
						sceneAdd(scene, createLine(ee[i], ee[i + 1], 0.02, 0x444444), "dynamic");

						var delta = ee[i + 1].clone().sub(ee[i]).multiplyScalar(1.0 / divs);
						var f1 = ee[i].clone();
						var f2 = f1.clone().add(delta);
						for (var j = 0; j < divs; j++) {
							var g1 = f1.clone().normalize().multiplyScalar(Math.sqrt(3));
							var g2 = f2.clone().normalize().multiplyScalar(Math.sqrt(3));

							sceneAdd(scene, createLine(project(g1), project(g2), 0.0252, 0x00ff00), "dynamic");
							var t = f1;
							f1 = f2;
							f2 = t.add(delta).add(delta);
						}
					}
					scene.doRender();

				}
				addProjection();
			}
		</script>

		<p>
			Stereographic projection is a projection from the surface of a sphere (in 3D) to a plane in 2D. In the example above, we
			have our cube embedded in a sphere in 3D. Notice, that the vertices will all be on the sphere surface - this is true for
			all regular polyhedra, also in four dimensions.
		</p>
		<p>
			The edges of the cube are black. These are projected (the red lines) by following a point on the top of sphere, through the
			vertex, and down on the plane. The projection edges are drawn in green.
		</p>
		<p>
			It is possible to rotate the cube using the controls. Notice, how the edges are curved when projected down onto the plane,
			even though they are straight in the cube. That is a choice: this corresponds to 'inflating' the cube onto the sphere, making the 
			edges live on the great circle arcs. 
		</p>
		<p>
			The stereographic projection can be generalized to higher dimensions. This is how we will create our depictions of four dimensional
			polytopes. We will start out with a 3-sphere in four-dimensional space. The vertices of the polytopes will be placed on
			the surface of the 3-sphere, and we will make a projection onto 3-dimensional space.
		</p>

		<div class="fullwidth">
			<img src="img6.jpg" width="100%" />
		</div>
		<h2>Putting it all together</h2>
		<p>
			Here is the final example - ray tracing a system of four generators:
		</p>

		<div class="rightBox" id="datGui2">
				Diagram: <span id="coxeter4d" style="display:inline"></span>
		</div>
		<script>
			var gui2 = new dat.GUI({ autoPlace: false });
			var staticContainer = document.getElementById("datGui2");
			insertCoxeter(document.getElementById("coxeter"), [5,3,3]);
			staticContainer.appendChild(gui2.domElement);

			function getModification4d(number) {
				// -, x---, -x--, xx--, --x-, x-x-, -xx-
				var names = ["Undefined", "Regular", "Rectified", "Truncated", "Birectified", "Cantellated", "Bitruncated", 
				//  xxx-, ---x, x--x, -x-x
				"Cantitruncated","Dual","Runcinated","Bicantellated",
				// xx-x, --xx, x-xx, -xxx, 
				"Runcitruncated", "Tritruncated", "Runcicantellated", "Bicantitruncated", "Runcicantitruncated"
				];
				return names[number];
			}
			function getBasicForm4d(degree) {
				var form = ["","","","5&#8209;Cell", "8&#8209;Cell", "120&#8209;Cell"];
				return form[degree];
			}

			var containerX = document.createElement('div');
			containerX.style.display = "inline";
			document.getElementById("main").appendChild(containerX);
			containerX.innerHTML = "<span style='width: 650px; height: 700px'><img src='inactive1.png' onclick='initializeMe()'></span>";
			var initializeMe = function () {
				containerX.innerHTML = "";
				loadFiles(['vertex.glsl', 'polytope.glsl', 'simpleRaymarcher.glsl'], function (s) {
					var scene = createFragmentShader(containerX, 650, 700, s[0], s[1] + s[2], gui2);
					scene.params.default = "16-cell";
					scene.addUniformsChangedListener( function() {
						document.getElementById("coxeter4d").innerHTML = "";
						var active = [scene.params["U"]>0,scene.params["V"]>0,scene.params["W"]>0,scene.params["T"]>0];
						insertCoxeter(document.getElementById("coxeter4d"), [scene.params["Degree"],3,3],active);
						var name = getModification4d(
							(scene.params["U"]>0 ? 1 : 0)+
							(scene.params["V"]>0 ? 2 : 0)+
							(scene.params["W"]>0 ? 4 : 0)+
							(scene.params["T"]>0 ? 8 : 0));
						document.getElementById("coxeter4d").innerHTML += name + "&nbsp;" + getBasicForm4d(scene.params["Degree"]);
						
					});gui2.add(scene.params, 'default', ["5-cell", "8-cell", "24-cell", "16-cell", "120-cell", "600-cell"]).name("Preset").onChange(function (v) {
						function set(name, val) {
							scene.params[name] = val;
							scene.uniforms[name] = { value: val };
						}
						function setRotation(x,y,z,angle) {
							scene.params["RotationX"] = x;
							scene.uniforms["RotationX"] = { value: x };
							scene.params["RotationY"] = y;
							scene.uniforms["RotationY"] = { value: y };
							scene.params["RotationZ"] = z;
							scene.uniforms["RotationZ"] = { value: z };
							scene.params["Angle"] = angle;
							scene.uniforms["Angle"] = { value: angle };
						}

						if (scene.params.default == "5-cell") {
							set("Degree", 3);
							set("U", 1.0);
							set("V", 0.0);
							set("W", 0.0);
							set("T", 0.0);
							setRotation(1,0,0,0);
							scene.doRender();
						} else if (scene.params.default == "8-cell") {
							set("Degree", 4);
							set("U", 1.0);
							set("V", 0.0);
							set("W", 0.0);
							set("T", 0.0);
							setRotation(0,1,0,90);
							scene.doRender();
						} else if (scene.params.default == "24-cell") {
							set("Degree", 4);
							set("U", 0.0);
							set("V", 0.0);
							set("W", 1.0);
							set("T", 0.0);
							setRotation(0,1,0,90);
							scene.doRender();
						} else if (scene.params.default == "16-cell") {
							set("Degree", 4);
							set("U", 0.0);
							set("V", 0.0);
							set("W", 0.0);
							set("T", 1.0);
							setRotation(1,0,0,0);
							scene.doRender();
						} else if (scene.params.default == "120-cell") {
							set("Degree", 5);
							set("U", 1.0);
							set("V", 0.0);
							set("W", 0.0);
							set("T", 0.0);
							setRotation(0,1,0,90);
							scene.doRender();
						} else if (scene.params.default == "600-cell") {
							set("Degree", 5);
							set("U", 0.0);
							set("V", 0.0);
							set("W", 0.0);
							set("T", 1.0);
							setRotation(1,0,0,0);
							scene.doRender();
						}
						scene.uniformsChanged();
					});

					scene.getCamera().position.set(7, 0, 0);
					scene.controls.update();
					scene.uniformsChanged();
				});
			};

		</script>
		<p>
				Similar to the 3D example, the U, V, W, and T parameters control the position of the initial vertex and the 
				Degree parameter controls one of the angles between the reflection planes.
		</p>
		<p>
			There is a set of controls for rotating the 4D object - this is similar to rotating the
			cube before projecting it down onto the plane in the previous illustration. Notice, that the rotation is not a true 4D rotation - only three coordinates get rotated.
			For some rotational values, the image gets fuzzy - I think this is when a vertex is close to the projection point of the 3-sphere and gets blown up.
		</p>
		<p>
			The presets can be used to quickly toggle between the regular 4D polychora. 
		</p>
		<p>
			There is one technicality that has to be taken into account when ray marching 4D polytopes. We march the ray in three dimensions
			- so in order to get the distance estimates we do an
			<em>inverse</em>
			stereographic projection to get to a four dimensional point (see also
			<a href="http://www.fractalforums.com/fragmentarium/solids-many-many-solids/msg41526/#msg41526">
				Knighty's original description</a>).
		</p>
		<p>Once in 4D, we can calculate the distance estimate by folding the point back into the fundamental domain.</p>

		<div class="fullwidth">
			<img src="img7.jpg" width="100%" />
		</div>
		<h2>In Summary</h2>
		<p>
			Many different geometric objects can be described by their Coxeter diagram, e.g.
			<span id="cox"></span>. This diagram describes the structure of the symmetry group by defining relations between the generators. The
			generators can be interpreted as reflections - and the power of the pair-wise relations describes the angle between the reflection
			planes.

		</p>
		<p>
			The Todd-Coxeter algorithm makes it possible to construct all elements in the symmetry group only from the description of the generator
			relations. It also allows us to find all cosets for a given sub-group. As we saw, by looking at the cosets for generator
			subgroups, we can identify edges, faces, and cells.
		</p>
		<p>
			Based on this we can construct an explicit geometry by choosing a starting point and applying the group transformations. For the
			regular polytopes, the initial vertex must be placed on the intersection of all reflection planes, except one.
		</p>
		<p>
			Instead of explicitly constructing all vertices, edges, and faces, it is possible to use a different approach: we can construct
			a function that for each point in space determines how close we are to a vertex or an edge - a distance estimator. We can do
			this by
			<em>folding</em> a given point in space repeatedly, until we reach our fundamental domain. This is powerful, because there
			are efficient methods for ray marching distance estimators (and it parallellizes trivally on GPU's).
		</p>
		<p>
			All of the above will work in any number of dimensions. However, in order to do the actual visualization, we used (inverse)
			stereographical projection to reduce the number of dimensions from four to three.
		</p>
	
		<p>
			Group theory and symmetries have been studied extensively by the math community, but most of
			the results are not very accessible unless you are a trained mathematician.</p>
			<p>This page is barely scratching the surface. I hope to get some time to look into hyperbolic geometries and
			<a href="https://en.wikipedia.org/wiki/Honeycomb_(geometry)">honeycombs</a>, both of which would fit naturally together with the regular polytopes - but until 
			then take a look at some of the links below.
		</p>
		<p>A secondary goal with this project was to build a more engaging and interactive web presentation than the static blog entries I usually write - I have been very impressed
				with what has been happening on sites like
				<a href="http://worrydream.com/">Bret Victor's Worry Dream</a> and
				<a href="https://distill.pub/">Distill.pub</a>. My most important lesson learned here, is that building interactive presentations do take up 
				a lot of time (duh). Some of this was partly because I needed to learn new techniques and create a couple of tools from scratch (like building a small three.js framework
				for ray tracing - including automatic generation of an UI for setting the uniforms). I plan to carve out some of these tools to make them easier to reuse for
				future projects. 
			</p>
		<p>
	<em>			All of the full width images were created using
				<a href="http://syntopia.github.io/Fragmentarium/">Fragmentarium</a>, which comes with several of Knighty's scripts. The source for this page can be found on
				<a href="https://github.com/Syntopia/Polytopia">Github</a>.
			</em>
			</p>
	
		<script>
			insertCoxeter(document.getElementById("cox"), [3, 5, 3]);
		</script>
		<div class="fullwidth">
			<img src="img8.jpg" width="100%" />
		</div>

		<h2>Links</h2>
		<p>
			<a href="https://www.math.cmu.edu/~fho/jenn/">Jenn 3D</a> (2001-2007) by Fritz Obermeyer.
			<br/>
			<a href="http://www.fractalforums.com/fragmentarium/solids-many-many-solids/">Knighty's fold method</a> (Fractal Forums thread from 2012).
			<br/>
			<a href="https://plus.google.com/114982179961753756261">Abdelaziz Nait Merzouk</a> (Knighty) on Google Plus
			<br/>
			<a href="http://blog.hvidtfeldts.net/index.php/2011/06/distance-estimated-3d-fractals-part-i/">My introduction to distance estimation</a>.
			<br/>
			<a href="http://www.josleys.com/index.php">Jos Leys</a> has also written about the
			<a href="http://images.math.cnrs.fr/Comment-dessiner-un.html?lang=fr">construction of 4D polytopes</a> - the page looks great, but is in French!
			<br/>

			<a href="https://terrytao.wordpress.com/2010/07/10/cayley-graphs-and-the-geometry-of-groups/">Cayley graphs</a> short introduction to Cayley graphs.
			<br/>
			<a href="https://math.berkeley.edu/~kmill/notes/todd_coxeter.html">Todd Coxeter</a> algorithm using the Schreier graph approach (which is used by Jenn 3D).
			<br/>
			<a href="https://math.stackexchange.com/questions/259545/meaning-of-a-regular-polytope">Meaning of regular polytope</a> explains what
			<em>flags</em> and transitive symmetries are.
			<br/>
			<a href="https://math.stackexchange.com/questions/735679/what-is-the-coxeter-diagram-for/764753">What is the Coxeter diagram for?</a> (StackExchange)
			<br/>
			<a href="http://www.ams.org/notices/199706/seress.pdf">An introduction to computational group theory</a>
			<br />
			<a href="http://torus.math.uiuc.edu/jms/Papers/dodecaplex/new.pdf">Generating and Rendering Four-Dimensional Polytopes
			</a> John M. Sullivan (1990).
			<br />
			<a href="http://roice3.org/">Roice Nelson</a> has some great visualizations (several being used on Wikipedia).
		</p>
		<p>Wikipedia has lots of (good) information:
			<a href="https://en.wikipedia.org/wiki/Uniform_polytope">Uniform polytope</a>
			<a href="https://en.wikipedia.org/wiki/Todd%E2%80%93Coxeter_algorithm">ToddCoxeter algorithm</a>,
			<a href="https://en.wikipedia.org/wiki/Coxeter_group">Coxeter group</a>,
			<a href="https://en.wikipedia.org/wiki/Coxeter%E2%80%93Dynkin_diagram">CoxeterDynkin diagram</a>,
			<a href="https://en.wikipedia.org/wiki/Polyhedron">Polyhedron</a>,
			<a href="https://en.wikipedia.org/wiki/Honeycomb_(geometry)">Honeycombs</a>
		</p>
		<p>
			I have also heard good things about John Conway's
			<a href="https://www.amazon.com/Symmetries-Things-John-H-Conway/dp/1568812205">The symmetries of things</a>, but I haven't read it myself.
		</p>

	</div>
</body>

</html>