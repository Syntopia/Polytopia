<!DOCTYPE html>
<html lang="en">

<head>
	<title>threejs webgl - materials - transparency</title>
	<style>
		body {
			color: #000;
			background-color: #fff;

		}

		body {
			font-family: 'Lato', serif;
			font-size: 20px;
			line-height: 28px;
		}

		.main {
			display: table;
			max-width: 800px;
			/*whatever you want*/
			min-width: 600px;
			width: auto;
			margin: 50px 10px 50px 150px;
		}

		h1,
		h2,
		h3,
		h4 {
			font-family: 'Lato', serif;
			font-weight: 400;
			position: relative;
			left: -50px;
		}

		table.blueTable {
			border-collapse: collapse;
			padding: 10px;
			font-size: 13px;
			margin: 0px;
			max-height: 600px;
			display: inline-block;
		}

		table.blueTable tr.highlight {
			background-color: rgb(231, 181, 71);
		}

		table.blueTable tr.highlight:nth-child(even) {
			background-color: rgb(231, 181, 71);
		}

		table.blueTable td,
		table.blueTable th {
			border: 1px solid #AAAAAA;
			padding: 3px 2px;
		}

		table.blueTable tbody td {
			//font-size: 8px;
		}

		table.blueTable tr:nth-child(even) {
			background: #D0E4F5;
		}

		table.blueTable thead {
			background: rgb(231, 243, 253);
		}

		table.blueTable thead th {
			//font-size: 10px;
		}

		a.interactive {
			border-bottom: 1px dashed #ffa500;
			color: #a66c00;
			display: inline-block;
			line-height: 100%;
			text-decoration: none;

			-moz-transition: all .5s;
			-o-transition: all .5s;
			-webkit-transition: all .5s;
			transition: all .5s;
		}

		a.interactive:hover {
			border-bottom-color: #a66c00;
			color: #ffa500;
		}

		#table-scroll {
			max-height: 650px;
			display: inline-block;
			width: auto;
			overflow-y: auto;
		}

		select {
			background: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='50px' height='50px'><polyline points='46.139,15.518 25.166,36.49 4.193,15.519'/></svg>");
			background-color: #3498DB;
			background-repeat: no-repeat;
			background-position: right 10px top 15px;
			background-size: 16px 16px;
			color: white;
			padding: 12px;
			width: auto;
			font-family: arial, tahoma;
			font-size: 16px;
			font-weight: bold;
			color: #fff;
			text-align: center;
			text-shadow: 0 -1px 0 rgba(0, 0, 0, 0.25);
			border-radius: 3px;
			-webkit-border-radius: 3px;
			-webkit-appearance: none;
			border: 0;
			outline: 0;
			-webkit-transition: 0.3s ease all;
			-moz-transition: 0.3s ease all;
			-ms-transition: 0.3s ease all;
			-o-transition: 0.3s ease all;
			transition: 0.3s ease all;
		}

		#s1 {
			background-color: #3498DB;
		}

		#s1:hover {
			background-color: #2980B9;
		}

		#s2 {
			background-color: rgb(255, 166, 0);
		}

		#s2:hover {
			background-color: rgb(180, 118, 1);
		}

		/* ------------------------------------------------------------------------------------------------------------------- */

		/* all of this style code just styles the input slider (autogenerated from http://www.cssportal.com/style-input-range/) */

		input[type=range] {
			-webkit-appearance: none;
			margin: 0px 0;
			width: 100%;
		}

		input[type=range]:focus {
			outline: none;
		}

		input[type=range]::-webkit-slider-runnable-track {
			width: 100%;
			height: 1px;
			cursor: pointer;
			animate: 0.2s;
			box-shadow: 0px 0px 0px #858585;
			background: #3071A9;
			border-radius: 0px;
			border: 1px solid #878787;
		}

		input[type=range]::-webkit-slider-thumb {
			box-shadow: 1px 1px 1px #000000;
			border: 1px solid #000000;
			height: 16px;
			width: 16px;
			border-radius: 16px;
			background: #FFFFFF;
			cursor: pointer;
			-webkit-appearance: none;
			margin-top: -8.5px;
		}

		input[type=range]:focus::-webkit-slider-runnable-track {
			background: #3071A9;
		}

		input[type=range]::-moz-range-track {
			width: 100%;
			height: 1px;
			cursor: pointer;
			animate: 0.2s;
			box-shadow: 0px 0px 0px #858585;
			background: #3071A9;
			border-radius: 0px;
			border: 1px solid #878787;
		}

		input[type=range]::-moz-range-thumb {
			box-shadow: 1px 1px 1px #000000;
			border: 1px solid #000000;
			height: 16px;
			width: 16px;
			border-radius: 16px;
			background: #FFFFFF;
			cursor: pointer;
		}

		input[type=range]::-ms-track {
			width: 100%;
			height: 1px;
			cursor: pointer;
			animate: 0.2s;
			background: transparent;
			border-color: transparent;
			color: transparent;
		}

		input[type=range]::-ms-fill-lower {
			background: #3071A9;
			border: 1px solid #878787;
			border-radius: 0px;
			box-shadow: 0px 0px 0px #858585;
		}

		input[type=range]::-ms-fill-upper {
			background: #3071A9;
			border: 1px solid #878787;
			border-radius: 0px;
			box-shadow: 0px 0px 0px #858585;
		}

		input[type=range]::-ms-thumb {
			box-shadow: 1px 1px 1px #000000;
			border: 1px solid #000000;
			height: 16px;
			width: 16px;
			border-radius: 16px;
			background: #FFFFFF;
			cursor: pointer;
		}

		input[type=range]:focus::-ms-fill-lower {
			background: #3071A9;
		}

		input[type=range]:focus::-ms-fill-upper {
			background: #3071A9;
		}
	</style>
	<link href="https://fonts.googleapis.com/css?family=Lato" rel="stylesheet">
</head>

<body>

	<div class="main" id="main">
		<script src="js/three.min.js" type="text/javascript"></script>
		<script src="js/OrbitControls.js" type="text/javascript"></script>
		<script src="js/Detector.js" type="text/javascript"></script>
		<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/svg.js/2.6.4/svg.js" integrity="sha256-Vfh4R0uOWH2tv2NrGrtTZUo+hRBMGtEczBeTz3CSvj4="
		 crossorigin="anonymous"></script>
		<script src="toddcoxeter.js" type="text/javascript"></script>

		<script>
			var showSceneObjects;
		</script>
		<h1>Building four dimensional polytopes</h1>
		<p>
			Several years ago I stumbled upon
			<a href="https://www.math.cmu.edu/~fho/jenn/">Jenn 3D</a>, a tool for visualizing four dimensional geometric structures. Jenn describes itself as follows:</p>
		<p>
			<em>Jenn is a toy for playing with various quotients of Cayley graphs of finite Coxeter groups on four generators. Jenn builds
				the graphs using the Todd-Coxeter algorithm, embeds them into the 3-sphere, and stereographically projects them onto
				euclidean 3-space.
			</em>
		</p>
		<p>



		</p>



		<script>

			function createLine(from, to, width, color, arrowWidth, arrowLength) {
				var m = new THREE.MeshStandardMaterial({
					color: color,
				});
				var dist = from.distanceTo(to);

				var geometry = new THREE.CylinderGeometry(width, width, dist, 10, 1);
				var mesh = new THREE.Mesh(geometry, m);
				var axis = new THREE.Vector3(0, 1, 0);

				if (arrowWidth != undefined) {
					var geometry2 = new THREE.CylinderGeometry(0, arrowWidth, arrowLength, 10, 1);
					geometry2.translate(0, dist / 2, 0);
					geometry.merge(geometry2);
				}

				var vector = (new THREE.Vector3()).subVectors(to, from);


				mesh.quaternion.setFromUnitVectors(axis, vector.clone().normalize());
				mesh.position.copy(from.clone().addScaledVector(vector, 0.5));

				return mesh;
			}

			function createPlane(v1, v2, v4, color) {
				var m = new THREE.MeshStandardMaterial({
					opacity: 0.8,
					transparent: true,
					side: THREE.DoubleSide,
					color: color,
				});

				var g = new THREE.Geometry();

				var d1 = new THREE.Vector3().addScaledVector(v2, 1).addScaledVector(v1, -1);
				var d2 = new THREE.Vector3().addScaledVector(v4, 1).addScaledVector(v1, -1);

				var divs = 14;
				var offset = 0;
				for (var i = 0; i < divs; i++) {
					for (var j = 0; j < divs; j++) {
						var x1 = new THREE.Vector3().addScaledVector(v1, 1).addScaledVector(d1, i / divs).addScaledVector(d2, j / divs);
						var x2 = new THREE.Vector3().addScaledVector(v1, 1).addScaledVector(d1, (i + 1) / divs).addScaledVector(d2, j / divs);
						var x3 = new THREE.Vector3().addScaledVector(v1, 1).addScaledVector(d1, i / divs).addScaledVector(d2, (j + 1) / divs);
						var x4 = new THREE.Vector3().addScaledVector(v1, 1).addScaledVector(d1, (i + 1) / divs).addScaledVector(d2, (j + 1) / divs);
						g.vertices.push(x1, x2, x4, x3);
						g.faces.push(new THREE.Face3(offset, offset + 1, offset + 2), new THREE.Face3(offset + 2, offset + 3, offset));
						offset += 4;
					}
				}
				g.computeFlatVertexNormals();
				return new THREE.Mesh(g, m);
			}


			function getStandard3DView(container, w, h) {
				var camera = new THREE.PerspectiveCamera(40, w / h, 1, 2000);
				camera.position.set(0.0, 1.4, 1.4 * 3.5);
				var scene2 = new THREE.Scene({ antialias: true });
				//scene2.background = new THREE.Color(0xffffff);
				scene2.add(camera);

				var ambientLight = new THREE.AmbientLight(0xffffff);
				camera.add(ambientLight);
				var directionalLight = new THREE.DirectionalLight(0xffffff, 1);
				directionalLight.position.set(0, 2, 9);
				camera.add(directionalLight);

				var renderer = new THREE.WebGLRenderer({ alpha: true });
				renderer.setClearColor(0x000000, 0);
				renderer.setPixelRatio(window.devicePixelRatio);
				renderer.setSize(w, h);
				container.appendChild(renderer.domElement);

				var controls = new THREE.OrbitControls(camera, renderer.domElement);
				controls.addEventListener('change', function () { renderer.render(scene2, camera); });
				scene2.doRender = function () { renderer.render(scene2, camera) };
				setTimeout(function () { renderer.render(scene2, camera) });
				return scene2;
			}

			function mid(v1, v2) {
				return new THREE.Vector3().addScaledVector(v1, 0.5).addScaledVector(v2, 0.5);
			}

			function sub(v1, v2) {
				return new THREE.Vector3().subVectors(v1, v2);
			}

			function add(v1, v2) {
				return new THREE.Vector3().addVectors(v1, v2);
			}

			function getSideWidth() {
				return 300;
			}

			function getContainer(offset) {
				var container = document.createElement('div');
				container.style.position = "absolute";
				container.style.width = "1px";
				container.style.height = "1px";
				container.style.zOrder = "-1";



				var inner = document.createElement('div');
				inner.style.position = "relative";
				inner.style.left = (document.getElementById("main").getBoundingClientRect().width) + "px";
				inner.style.top = offset + "px";
				inner.style.width = (getSideWidth()) + "px";
				container.appendChild(inner);
				document.getElementById("main").appendChild(container);
				return inner;
			}
			if (!Detector.webgl) Detector.addGetWebGLMessage();

			function getVertices() {
				var v = [new THREE.Vector3(-1, -1, -1), new THREE.Vector3(-1, 1, -1), new THREE.Vector3(1, 1, -1), new THREE.Vector3(1, -1, -1),
				new THREE.Vector3(-1, -1, 1), new THREE.Vector3(-1, 1, 1), new THREE.Vector3(1, 1, 1), new THREE.Vector3(1, -1, 1)];
				return v;
			};

			function getEdges() {
				var v = getVertices();
				var e = [];
				e.push(v[0], v[1], v[1], v[2], v[2], v[3], v[3], v[0]);
				e.push(v[4], v[5], v[5], v[6], v[6], v[7], v[7], v[4]);
				e.push(v[0], v[4], v[1], v[5], v[2], v[6], v[3], v[7]);
				return e;
			};

			// Coxeter diagram. Cube will have relations=[4,3]
			function insertCoxeter(container, relations, col) {

				//	var container = document.createElement('div');
				//	document.getElementById("main").appendChild(container);
				var cx = 7;
				var spacingY = 20;
				var y = 13;
				var radius = 8;
				var gens = relations.length + 1;

				var draw = SVG(container).size(cx + spacingY * gens - 4, 25);

				var colors = (col == undefined ? ['black', 'black', 'black', 'black'] : col);
				draw.line(cx, y + radius / 2, cx + (gens - 1) * spacingY, y + radius / 2).stroke({ width: 1 });

				draw.circle(12).x(cx - 2).y(y - 2).stroke({ width: 1 }).fill('none');


				for (var i = 0; i < gens; i++) {
					//s += '<circle cx="' + cx + '" cy="15" r="4" stroke="black" stroke-width="1" fill="' + colors[i] + '" />';
					draw.circle(8).x(cx).y(y).stroke({ width: 1 });
					cx += spacingY;
					if (i < gens - 1 && relations[i] > 3)
						draw.text(relations[i] + "").x(cx - 11).y(y - 10).font({ size: 12 });
				}
			}


		</script>

		<h2>Example: symmetries of the cube</h2>
		<p>
			Let us start with a simple three dimensional cube. </p>

		<script>


			function sceneAdd(scene, object, group) {
				if (scene.groupings == undefined) {
					scene.groupings = new Map();
				}
				if (scene.groupings.get(group) == undefined) {
					scene.groupings.set(group, []);
				}
				scene.groupings.get(group).push(object);
				scene.add(object);
			}

			init();
			function init() {
				var scene = getStandard3DView(getContainer(-50), getSideWidth(), getSideWidth());

				var v = getVertices();
				var e = getEdges();

				scene.add(createPlane(v[0], v[1], v[3], 0xff0000)); // top
				scene.add(createPlane(v[5], v[6], v[4], 0xff0000)); // bottom
				scene.add(createPlane(v[3], v[2], v[7], 0x00ff00)); // right
				scene.add(createPlane(v[0], v[1], v[4], 0x00ff00)); // left
				scene.add(createPlane(v[0], v[3], v[4], 0x0000ff)); // front
				scene.add(createPlane(v[1], v[2], v[5], 0x0000ff)); // back

				v.forEach(function (vv) { vv.multiplyScalar(1.3); });
				var w = 0.05;
				var c = 0xffffff;
				sceneAdd(scene, createLine(v[0], v[6], w, c), "vertices");
				sceneAdd(scene, createLine(v[1], v[7], w, c), "vertices");
				sceneAdd(scene, createLine(v[2], v[4], w, c), "vertices");
				sceneAdd(scene, createLine(v[3], v[5], w, c), "vertices");

				showSceneObjects = function (category) {
					scene.groupings.forEach(function (c) {
						c.forEach(function (obj) { obj.visible = (category == undefined ? true : false); })
					});
					if (category != undefined)
						scene.groupings.get(category).forEach(function (obj) { obj.visible = true; });
					scene.doRender();
				};

				var l = 1.5; w = 0.05; c = 0xff5566;
				sceneAdd(scene, createLine(new THREE.Vector3(-l, 0, 0), new THREE.Vector3(l, 0, 0), w, c), "faces");
				sceneAdd(scene, createLine(new THREE.Vector3(0, -l, 0), new THREE.Vector3(0, l, 0), w, c), "faces");
				sceneAdd(scene, createLine(new THREE.Vector3(0, 0, -l), new THREE.Vector3(0, 0, l), w, c), "faces");
				var c = 0x5566ff;
				for (var i = 0; i < e.length; i += 2) {
					var v1 = mid(e[i], e[i + 1]).multiplyScalar(1.2);
					var v2 = v1.clone().multiplyScalar(-1);
					sceneAdd(scene, createLine(v1, v2, w, c), "edges");
				}
			}
		</script>


		<script>
			function init() {
				var scene = getStandard3DView(getContainer(getSideWidth() - 50), getSideWidth(), getSideWidth());

				var v = getVertices();
				var e = getEdges();

				for (var i = 0; i < e.length; i += 2) {
					scene.add(createLine(e[i], e[i + 1], 0.02, 0xffffff));
				}
				scene.add(createPlane(v[0], v[2], v[4], 0xff0000));
				scene.add(createPlane(v[1], v[3], v[5], 0xff0000));
				scene.add(createPlane(v[0], v[3], v[5], 0x00ff00));
				scene.add(createPlane(v[1], v[2], v[4], 0x00ff00));
				scene.add(createPlane(v[4], v[5], v[3], 0x333333));
				scene.add(createPlane(v[0], v[1], v[7], 0x333333));
				scene.add(createPlane(mid(v[0], v[3]), mid(v[1], v[2]), mid(v[4], v[7]), 0x0000ff));
				scene.add(createPlane(mid(v[0], v[1]), mid(v[2], v[3]), mid(v[4], v[5]), 0x0000ff));
				scene.add(createPlane(mid(v[0], v[4]), mid(v[3], v[7]), mid(v[1], v[5]), 0x0000ff));
			}

			init();


		</script>

		<p>The cube has several
			<em>automorphisms</em> - transformations that will map the cube onto itself. For instance, we can easily find several rotations
			(between
			<a href="" class="interactive" onmouseover="showSceneObjects('vertices')" onmouseout="showSceneObjects()">opposite vertices</a>: 4 (120 degrees), opposite
			<a href="" class="interactive" onmouseover="showSceneObjects('edges')" onmouseout="showSceneObjects()">mid-edges</a>: 6 (180 degrees), opposite
			<a href="" class="interactive" onmouseover="showSceneObjects('faces')" onmouseout="showSceneObjects()">faces</a>: 3 (90 degrees): a total of: 4*2+6*1+3*3 = 23 rotations.
		</p>
		<p> Including the identity transformation, and taking into account that we could also mirror every one of these transformations,
			we arrive at
			<b>48</b> automorphisms of the cube.
		</p>
		<p>
			Shown to the right are the 9 different reflection operations, that will also map the cube onto itself (although in i mirrored
			version).
		</p>
		<p>These 48 transformations form a
			<b>group</b>: a set of elements, together with a rule for combining any two elements such that the result is again an element
			in the set. There must an identity element in the group, and every element must have an inverse element: i.e. an element
			such that combining the element and its inverse, results in the identity element.
		</p>
		<p>
			In our case, combining any number of the 48 transformations will result in a transformation that is already in the present
			in our set of transformations. Likewise, for all rotations and reflections there exists an inverse transformation (for
			180 degrees transformations, and for reflections, these transformations are their own inverses).
		</p>
		<p>These transformations are not independent: some transformations can be expressed by combining other transformations. Perhaps
			it is possible to find a smaller subset of transformation, that can be combined to form all the 48 automorphisms?
		</p>
		<p>
			This is know a set of
			<b>generators</b>: a subset, S, of elements in the group G, which can be used to express all elements (using their inverses
			as well).
		</p>





		<script>

			function init() {
				var scene = getStandard3DView(getContainer(100), getSideWidth(), getSideWidth());

				var v = getVertices();
				var e = getEdges();

				for (var i = 0; i < e.length; i += 2) {
					scene.add(createLine(e[i], e[i + 1], 0.02, 0xffffff));
				}

				scene.add(createPlane(v[0], v[2], v[4], 0x00ff00));
				scene.add(createPlane(v[0], v[3], v[5], 0x0000ff));
				scene.add(createPlane(mid(v[0], v[3]), mid(v[1], v[2]), mid(v[4], v[7]), 0xff0000));
			}


			init();

		</script>
		<p>
			For the cube, it is possible to find a set of three reflections, which can be used to form all the 48 transformations. The
			set is shown to the right: here we have three reflection planes, which we could think of as operators - let us call them
			R, G, and B after their colors. This set can be used to construct all other transformations.
		</p>
		<p>
			Notice that the angle between the reflection planes are: $$\angle(R,G) = 45^{\circ} $$ $$\angle(G,B) = 60^{\circ} $$ $$\angle(R,B)
			= 90^{\circ} $$
		</p>
		<p>
			Now, combining two reflections, result in a rotation of twice the angle between the reflection planes. So applying e.g. GB
			would be equal to a rotation of 120 degrees. And applying GB three times, e.g. GBGBGB, would not change the input.
		</p>
		<p>This means we can establish the following
			<b>relations</b> between the generators:</p>
		$$R^2 = B^2 = G^2 = (RG)^4 = (GB)^3 = (RB)^2 = I$$
		<p>
			Now, given this set of generators, how many different elements are there in our set? For instance, are (RBGR)^n different
			elements for all n? This turns out to be a computationally hard problem, known as the
			<a href="https://en.wikipedia.org/wiki/Word_problem_for_groups">word problem for groups</a>.
		</p>


		<h2>The Todd-Coexeter Algorithm</h2>

		<p>
			Coxeter group: relations on the form \((ab)^{m_{ab}}\).
		</p>

		<p>
			The
			<a href="https://en.wikipedia.org/wiki/Todd%E2%80%93Coxeter_algorithm">Todd-Coxeter Algorithm</a> a provides a way to identify and count all elements generated by our generators.
		</p>
		<p>Actually, the algorithm does a bit more: it allows for enumerating all cosets of G, for a given subgroup H. </p>
		<p>What does this mean?</p>
			<p>
			A coset is the set resulting by multiplying the all members in \(H\) by a group element from, \(g\). A (left) coset is written
			\(gH\). The number of cosets is written \(|G:H|\). Lagrange's theorem states that \( [G:H]={|G| \over |H|} \). The cosets
			for a subgroup form a new set, called a
			<b>quotient set</b> (denoted G/H).
		</p>
		<p>The Todd-Coxeter algorithm might be the first non-numerical algorithm to be implemented on a digital computer (using a
			<a href="https://www.cambridge.org/core/journals/mathematical-proceedings-of-the-cambridge-philosophical-society/article/coset-enumeration-on-digital-computers/047323FB9415ACF3466E627590ABB790">
				EDSAC 1 in 1953</a>) </p>
		<p>The algorithm works by keeping track of several tables: a coset table (listing the generator actions on the different cosets),
			a subgroup table (listing sub group generator actions), and a table for each relation between the group generators. The
			algorithm works by filling out rows in these tables. Once a row is closed, a (potentially) new piece of information is
			known.
		</p>
		<p> Here is a demo:
		</p>
		<p>
			Group:
			<select onchange="updateToddCoxeter()" id="s1" style="width: 350px">
				<option>rgrgrg,gbgbgb,rbrb (tetrahedron)</option>
				<option selected="selected">rgrgrgrg,gbgbgb,rbrb (cube)</option>
				<option>rgrgrg,gbgbgbgb,rbrb (octa)</option>
				<option>rgrgrgrgrg,gbgbgb,rbrb (dodecahedron)</option>
				<option>rgrgrg,gbgbgbgbgb,rbrb (icosahedron)</option>
			</select>
			Subgroup:
			<select onchange="updateToddCoxeter()" id="s2" style="width: 150px">
				<option>none</option>
				<option>r,g</option>
				<option>g,b</option>
				<option selected="selected">r,b</option>
			</select>
			<a href="javascript:doStep()" class="interactive">Step</a>

			<div id="output"></div>

			<script>

				var tcStep;
				var doIteration;
				var iter = 0;

				function doStep() {
					if (tcStep == undefined) {
						tcStep = getTC();
						doIteration = tcStep.initSolver();
						iter = 0;
					}
					if (!doIteration()) {
						var d = document.getElementById("output");
						d.innerHTML = "<p>Number of cosets:" + tcStep.cosetTable.rows.length + "</p>" + tcStep.getTables();
						tcStep = undefined; // reset

						return;
					}
					var d = document.getElementById("output");
					d.innerHTML = "<p><b>In progress (step " + (++iter) + ")</b><p>" + tcStep.getTables();

				}

				function getTC() {

					var e = document.getElementById("s1");
					var group = e.options[e.selectedIndex].value.split(" ")[0];

					var e = document.getElementById("s2");
					var subgroup = e.options[e.selectedIndex].value;
					if (subgroup == "none") subgroup = undefined;

					var tc = new ToddCoxeter(group, subgroup);
					return tc;
				}

				function updateToddCoxeter() {
					tcStep = undefined; // reset
					var tc = getTC();
					tc.solve();
					var d = document.getElementById("output");
					d.innerHTML = "<p>Number of cosets:" + tc.getCosetCounts() + "<p>" + tc.getTables();
				}

				updateToddCoxeter();


			</script>
	
		<p>Let us look at the variuos cosets you get when you use Todd-Coxeter on the symmetry groups, using different subsets of
			the generators to specify a subgroup:</p>
		<p>

			<table class="blueTable inlineCoxeter">
				<thead>
					<tr>
					<th colspan=4 style="background: #fff; border: 0px"></th>
					<th colspan=3>Subgroup cosets</th>
					</tr>
				</thead>
				<thead>
					<tr>
					<th>Name</th>
					<th>Diagram</th>
					<th>Generator relations</th>
					<th>Automorphisms</th>
					<th>g,b</th>
					<th>r,b</th>
					<th>r,g</th>
					</tr>
				</thead>
				<tbody>
					<tr>
						<td>Tetrahedron</td>
						<td>COX(3,3)</td>
						<td>\((rg)^3\),\((gb)^3\);\((rb)^2\)</td>
						<td>24</td>
						<td>4</td>
						<td>6</td>
						<td>4</td>
					</tr>
					<tr>
						<td>Cube</td>
						<td>COX(4,3)</td>
						<td>\((rg)^4\),\((gb)^3\),\((rb)^2\)</td>
						<td>48</td>
						<td>8</td>
						<td>12</td>
						<td>6</td>
					</tr>
					<tr>
						<td>Octahedron</td>
						<td>COX(3,4)</td>
						<td>\((rg)^3\),\((gb)^4\),\((rb)^2\)</td>
						<td>48</td>
						<td>6</td>
						<td>12</td>
						<td>8</td>
					</tr>
					<tr>
						<td>Dodecahedron</td>
						<td>COX(5,3)</td>
						<td>\((rg)^5\),\((gb)^3\),\((rb)^2\)</td>
						<td>120</td>
						<td>20</td>
						<td>30</td>
						<td>12</td>
					</tr>
					<tr>
						<td>Icosahedron</td>
						<td>COX(3,5)</td>
						<td>\((rg)^3\),\((gb)^5\),\((rb)^2\)</td>
						<td>120</td>
						<td>12</td>
						<td>30</td>
						<td>20</td>
					</tr>
					<tr>
						<th colspan=4 style="background: #fff; border: 0px"></th>
						<th>Vertices</th>
						<th>Edges</th>
						<th>Faces</th>
						</tr>
				</tbody>
			</table>


			<table class="blueTable inlineCoxeter">
				<thead>
				<tr>
					<th colspan=4 style="background: #fff; border: 0px"></th>
					<th colspan=4>Subgroup cosets</th>
				</tr>
				</thead>
				<thead>
					<tr>
					<th>Name</th>
					<th>Diagrams</th>
					<th>Generator relations</th>
					<th>Automorphisms</th>
					<th>g,b,a</th>
					<th>r,b,a</th>
					<th>r,g,a</th>
					<th>r,g,b</th>
				</tr>
				</thead>
				<tbody>
					<tr>
						<td>5-cell</td>
						<td>COX(3,3,3)</td>
						<td>\((rg)^3\),\((gb)^3\),\((ba)^3\),\((rb)^2\),\((ra)^2\),\((ga)^2\)</td>
						<td>120</td>
						<td>5</td>
						<td>10</td>
						<td>10</td>
						<td>5</td>
					</tr>
					<tr>
						<td>8-cell</td>
						<td>COX(4,3,3)</td>
						<td>\((rg)^4\),\((gb)^3\),\((ba)^3\),\((rb)^2\),\((ra)^2\),\((ga)^2\)</td>
						<td>384</td>
						<td>16</td>
						<td>32</td>
						<td>24</td>
						<td>8</td>
					</tr>
					<tr>
						<td>16-cell</td>
						<td>COX(3,3,4)</td>
						<td>\((rg)^3\),\((gb)^3\),\((ba)^4\),\((rb)^2\),\((ra)^2\),\((ga)^2\)</td>
						<td>384</td>
						<td>8</td>
						<td>24</td>
						<td>32</td>
						<td>16</td>
					</tr>
					<tr>
						<td>24-cell</td>
						<td>COX(3,4,3)</td>
						<td>\((rg)^3\),\((gb)^4\),\((ba)^3\),\((rb)^2\),\((ra)^2\),\((ga)^2\)</td>
						<td>1152</td>
						<td>24</td>
						<td>96</td>
						<td>96</td>
						<td>24</td>
					</tr>
					<tr>
						<td>120-cell</td>
						<td>COX(5,3,3)</td>
						<td>\((rg)^5\),\((gb)^3\),\((ba)^3\),\((rb)^2\),\((ra)^2\),\((ga)^2\)</td>
						<td>14400</td>
						<td>600</td>
						<td>1200</td>
						<td>720</td>
						<td>120</td>
					</tr>
					<tr>
						<td>600-cell</td>
						<td>COX(3,3,5)</td>
						<td>\((rg)^3\),\((gb)^3\),\((ba)^5\),\((rb)^2\),\((ra)^2\),\((ga)^2\)</td>
						<td>14400</td>
						<td>120</td>
						<td>720</td>
						<td>1200</td>
						<td>600</td>
					</tr>
					<tr>
						<th colspan=4 style="background: #fff; border: 0px"></th>
						<th>Vertices</th>
						<th>Edges</th>
						<th>Faces</th>
						<th>Cells</th>
						</tr>
				</tbody>
			</table>

			<script>
				var tables = document.getElementsByClassName("inlineCoxeter");
				for (var t = 0, table; table = tables[t]; t++)

					for (var i = 0, row; row = table.rows[i]; i++) {
						for (var j = 0, c; c = row.cells[j]; j++) {
							if (c.innerText && c.innerText.indexOf("COX")!=-1) {

								var reg = /COX\((.*)\)/g;
								var match = reg.exec(c.innerText);
								c.innerText = "";
								insertCoxeter(c, match[1].split(","));
							}
						}
					}

			</script>
		

		<p>An interesting structure emerges here: looking at the cosets for the subgroups generated by leaving out one of the generators,
			<em>the number of cosets</em> matches the number of vertices, edges, or faces! It seems we can fully describe the geometric
			structure by forming various quotient sets.</p>
		<p>
			Also notice, that the ordering matter here: the cube and octahedron have the same generators (just switch 'r' and 'b'), and
			same symmetry group, but the number of faces and vertices are swapped. These shapes are said to be
			<b>dual</b>. The Dodecahedron/Icosahedron, the 8-cell/16-cell, and 120-cell/600-cell all form dual pairs. So what differentiates
			a cube from an octahedron? The answer is, that it depends on how the initial vertex is placed. Notice the outer circle
			on the first reflector, r, in the Coxeter diagram: this means that the initial vertex should be placed somewhere
			<em>off</em> the reflection plane for r, but on both the reflection planes for g and b. (This also means that the initial
			vertex would be taken to itself when applying g and b).

		</p>

		<p>
			Let us explore the quotient sets a bit more - for instance, how do we know how to associate edges with vertices?
		</p>
		<h2>Generating geometry from group structure</h2>
		<p>
			Let us see how to recreate the euclidean geometry from the abstract Coxeter group description.
		</p>
		<p>
			Given the generator relations, we now the angle between the reflector planes (e.g. 90, 120, 180 for the cube). The first
			step is to create a set of vectors with these angles between. This can be done iteratively, by start with an arbitrary
			unit vector, and adding vectors that fullfill the relation, e.g.:

		</p>
		<p>
		$$ \begin{pmatrix} & 1 & cos(\theta_{12}) & cos(\theta_{13}) \\ & 0 & \sqrt{1-cos^2(\theta_{12})} & \frac{cos(\theta_{23})-
		cos(\theta_{12})cos(\theta_{13}) }{\sqrt{1-cos^2(\theta_{12})}} \\ & 0 & 0 & N \end{pmatrix} $$
		</p>
		<p>Here the columns represent the normals of the reflecting planes (N is a normalization constant, I skipped - all the normals
			must be unit length)</p>
		<p>
			We also need to figure out a starting point: gram-schmidt: take the ordered set of normals and create an orthogonal representation.
			Since the last vector in this orthogonal representation must be both perpendicular to the first reflection plane normal,
			and to the second reflection plane normal, this vector must be in the intersection of the two reflection planes.
		</p>



		<script>

			function selectRow(col, r) {
				var table = document.getElementById("mainTable");

				var ct = freeGroup.cosetTable;
				var selected = (col == undefined ? -1 : ct.extraColumns[col][r]);

				for (var i = 1, row; row = table.rows[i]; i++) {
					var val = ct.extraColumns[col][i - 1];
					row.className = (val == selected ? "highlight" : "");

				}
			}

			function dumpTable(tc) {
				var table = tc.cosetTable;
				var genSymbols = tc.rels.generators;

				var mapper = function (e) { return self.rels.generators[e]; };
				var s = '<div id="table-scroll">';

				s += "<table class='blueTable' style='height: 600px' id='mainTable'><thead><th></th><th>Element</th>";
				for (var i = 0; i < table.genList.length; i++) {
					s += "<th>" + genSymbols[table.genList[i]] + "</th>";
				}
				if (table.extraColumns) {
					for (var i = 0; i < table.extraColumns.length; i++) {
						s += "<th> " + table.extraColumnNames[i][0] + "</th>";
					}
				}
				s += "</thead>";
				for (var i = 0; i < table.rows.length; i++) {
					s += "<tr><td>" + table.rowCosets[i] + "</td>";
					var el = tc.getRepresentiveString(tc.getRepresentiveForCoset(i));
					s += "<td>" + (el == "" ? "I" : el) + "</td>";

					for (var j = 0; j < table.genList.length; j++) {
						var o = table.rows[i][j];
						s += "<td>" + (o == undefined ? "" : o) + "</td>";
					}
					if (table.extraColumns) {
						for (var j = 0; j < table.extraColumns.length; j++) {
							s += "<td><a class='interactive' onmouseover='selectRow(" + j + "," + i + ")' onmouseout='selectRow(" + j + ")'>" + table.extraColumnNames[j][1] + table.extraColumns[j][i] + "</a></td>";
						}
					}
					s += "</tr>";
				}
				s += "</table></div>";
				return s;
			};

			function findSub(subgroupRelation, subgroupGenerators, name) {
				var tc = new ToddCoxeter(subgroupRelation);
				var total = tc.solve();
				var subgroupMembers = freeGroup.getCosetsForRepresentives(tc.translate(tc.getRepresentivesForCosets(), freeGroup));

				var tc = new ToddCoxeter(relations, subgroupGenerators);
				var total = tc.solve();

				var cosetActions = tc.translate(tc.getRepresentivesForCosets(), freeGroup);

				var subsets = freeGroup.apply(cosetActions, subgroupMembers);

				var vLabel = new Array(tc.getCosetCounts());
				for (var i = 0; i < subsets.length; i++) {
					for (var j = 0; j < subsets[i].length; j++) {
						vLabel[subsets[i][j]] = i;
					}
				}
				return vLabel;
			}

			var relations = "rgrgrgrg,gbgbgb,rbrb";
			var freeGroup = new ToddCoxeter(relations);
			var total = freeGroup.solve();
			freeGroup.cosetTable.extraColumns = [];
			freeGroup.cosetTable.extraColumnNames = [["Vertices", "V"], ["Edges", "E"], ["Faces", "F"], ["Cells", "C"]];
			freeGroup.cosetTable.extraColumns.push(findSub("gbgbgb", "g,b", "V"));
			freeGroup.cosetTable.extraColumns.push(findSub("rbrb", "r,b", "E"));
			freeGroup.cosetTable.extraColumns.push(findSub("rgrgrgrg", "r,g", "F"));

			// Find vertices
			// Returns { vertexOperators,  edgeList, faceList };
			function getStructure(group) {

				var vertices = 0;
				var edges = 0;
				var faces = 0;

				for (var i = 0; i < group.cosetTable.extraColumns[0].length; i++) {
					vertices = Math.max(group.cosetTable.extraColumns[0][i] + 1, vertices);
					edges = Math.max(group.cosetTable.extraColumns[0][i] + 1, edges);
					faces = Math.max(group.cosetTable.extraColumns[0][i] + 1, faces);
				}

				var vxs = new Array(vertices);
				var ms = new Array(vertices);

				// Vertices and reflection matrices
				var current = 0;
				for (var i = 0; i < group.cosetTable.extraColumns[0].length; i++) {
					var vertex = group.cosetTable.extraColumns[0][i];
					if (vxs[vertex] == undefined) {
						vxs[vertex] = group.getRepresentiveForCoset(i);
						console.log("Setting vertex " + vertex + " to " + vxs[vertex]);
					}
				}


				var edgeList = new Array(edges);
				var faceList = new Array(faces);

				// Edges and faces
				for (var i = 0; i < group.cosetTable.extraColumns[1].length; i++) {
					var v = group.cosetTable.extraColumns[0][i];
					var e = group.cosetTable.extraColumns[1][i];
					var f = group.cosetTable.extraColumns[2][i];
					if (edgeList[e] == undefined) edgeList[e] = [];
					if (edgeList[e].indexOf(v)==-1) edgeList[e].push(v);
 
					if (faceList[f] == undefined) faceList[f] = [];
					if (faceList[f].indexOf(e)==-1) faceList[f].push(e);


				}


				return { vertexOperators: vxs, edgeList: edgeList, faceList: faceList };
			}

			

			// Find vertices
			function getVertixMatrices(vertexOperators, reflectionMatrices) {
				var ms = new Array(vertexOperators.length);
				for (var i = 0; i < vertexOperators.length; i++) {
					var operatorList = vertexOperators[i];

					var m = new THREE.Matrix3();
					for (var j = 0; j < operatorList.length; j++) {
						m.premultiply(reflectionMatrices[operatorList[j]]);
					}
					ms[i] = m;
				}
				return ms;
			}

			var container = document.createElement('span');
			document.getElementById("main").appendChild(container);


			container.innerHTML += "<p>" + dumpTable(freeGroup);

		</script>
		<script>

			function cross(v1, v2) {
				return (new THREE.Vector3()).crossVectors(v1, v2);
			}


			function gramSchmidt(vs) {
				var out = [];

				for (var i = 0; i < vs.length; i++) {
					var v = vs[i].clone();

					for (var j = 0; j < out.length; j++) {
						v.projectOnPlane(out[j]);
					}

					out.push(v.normalize());
				}

				return out;
			}

			function getReflectionMatrix(nx, ny, nz) {
				//https://en.wikipedia.org/wiki/Transformation_matrix#Reflection_2
				var m = new THREE.Matrix3();
				m.set(
					1 - 2 * nx * nx, -2 * nx * ny, -2 * nx * nz,
					-2 * nx * ny, 1 - 2 * ny * ny, -2 * ny * nz,
					-2 * nx * nz, -2 * ny * nz, 1 - 2 * nz * nz);
				return m;
			}

			var setInitialVertex;

			values = {};

			function createSlider(container, name, label, defaultValue, min, max) {
				var html = "<div class='dynamicUI'><span id='" + name + "Label'>" + label + "&nbsp;&nbsp;</span>";
				html += "<input id='" + name + "Slider' value='" + 100 * (defaultValue - min) / (max - min) + "' type='range' min='0' max='100' style='width: 300px;'>";
				html += "&nbsp;&nbsp;<span id='" + name + "Value'>" + defaultValue.toFixed(3) + "</span></div>";
				container.insertAdjacentHTML('beforeend', html);

				var slider = document.getElementById(name + "Slider");
				var value = document.getElementById(name + "Value");
				values[name] = slider.value * 0.01 * (max - min) + min;

				slider.addEventListener('input', function () {
					var val = slider.value * 0.01 * (max - min) + min;
					value.innerHTML = val.toFixed(3);
					values[name] = val;
					setInitialVertex(values["nR"], values["nG"], values["nB"]);
				});
			}



			function init() {
				var container = document.createElement('div');
				//container.style.width = "800px";
				//scontainer.style.height = "800px";
				container.style.display = "inline";
				container.style.position = "absolute";
				//container.style.top = "-1px";
				//container.style.left = "";
				document.getElementById("main").appendChild(container);

				var scene = getStandard3DView(container, 700, 700);

				var v = [new THREE.Vector3(-1, -1, -1), new THREE.Vector3(-1, 1, -1), new THREE.Vector3(1, 1, -1), new THREE.Vector3(1, -1, -1),
				new THREE.Vector3(-1, -1, 1), new THREE.Vector3(-1, 1, 1), new THREE.Vector3(1, 1, 1), new THREE.Vector3(1, -1, 1)];

				var vertices = [];
				vertices.push(v[0], v[1], v[1], v[2], v[2], v[3], v[3], v[0]);
				vertices.push(v[4], v[5], v[5], v[6], v[6], v[7], v[7], v[4]);
				vertices.push(v[0], v[4], v[1], v[5], v[2], v[6], v[3], v[7]);
				for (var i = 0; i < vertices.length; i += 2) {
					//scene.add(createLine(vertices[i], vertices[i + 1], 0.02, 0xffffff));
				}

				scene.add(createPlane(v[0], v[2], v[4], 0x00ff00));
				scene.add(createPlane(v[0], v[3], v[5], 0x0000ff));
				var r1 = mid(v[0], v[3]);
				var r2 = mid(v[1], v[2]);
				var r3 = mid(v[4], v[7]);
				scene.add(createPlane(r1, r2, r3, 0xff0000));

				var nG = cross(sub(v[2], v[0]), sub(v[4], v[0])).normalize();
				var nB = cross(sub(v[3], v[0]), sub(v[5], v[0])).normalize();
				var nR = cross(sub(r2, r1), sub(r3, r1)).normalize();

				var nBp = gramSchmidt([nG, nR, nB])[2];
				var nRp = gramSchmidt([nB, nG, nR])[2];
				var nGp = gramSchmidt([nR, nB, nG])[2];
				if (nRp.dot(nBp) < 0) nRp.multiplyScalar(-1);
				if (nGp.dot(nBp) < 0) nGp.multiplyScalar(-1);


				var O = new THREE.Vector3(0, 0, 0);
				var w = 0.01;
				var arrowWidth = 0.03;
				var arrowLength = 0.1;

				scene.add(createLine(O, nGp.clone().multiplyScalar(2.0), w, 0x00ff00, arrowWidth, arrowLength));
				scene.add(createLine(O, nBp.clone().multiplyScalar(2.0), w, 0x0000ff, arrowWidth, arrowLength));
				scene.add(createLine(O, nRp.clone().multiplyScalar(2.0), w, 0xff0000, arrowWidth, arrowLength));


				// Get vertices
				var reflectionMatrices = [];
				reflectionMatrices.push(getReflectionMatrix(nR.x, nR.y, nR.z));
				reflectionMatrices.push(getReflectionMatrix(nG.x, nG.y, nG.z));
				reflectionMatrices.push(getReflectionMatrix(nB.x, nB.y, nB.z));

				var structure = getStructure(freeGroup);
				var ms = getVertixMatrices(structure.vertexOperators,reflectionMatrices);
				structure.vertexOperators;
				structure.edgeList;
				structure.faceList;
			
				var spheres = [];


				setInitialVertex = function (v1, v2, v3) {
					var pos = new THREE.Vector3(0, 0, 0);
					pos.addScaledVector(nRp, v1);
					pos.addScaledVector(nGp, v2);
					pos.addScaledVector(nBp, v3);

					for (var i = 0; i < spheres.length; i++) {
						scene.remove(spheres[i]);
						spheres[i].geometry.dispose();
					}
					spheres = [];

					for (var i = 0; i < ms.length; i++) {
						var geometry = new THREE.SphereGeometry(0.1, 32, 32);
						var material = new THREE.MeshStandardMaterial({ color: 0xffff00 });
						var sphere = new THREE.Mesh(geometry, material);
						console.log(pos.clone().applyMatrix3(ms[i]));
						sphere.position.copy(pos.clone().applyMatrix3(ms[i]));
						scene.add(sphere);
						spheres.push(sphere);

					}

					for (var i = 0; i < structure.edgeList.length; i++) {
						var v1 = structure.edgeList[i][0];
						var v2 = structure.edgeList[i][1];
						var s = createLine(spheres[v1].position, spheres[v2].position, 0.01, 0xff0000);
						scene.add(s);
						spheres.push(s);
					}
				
					scene.doRender();
				}

				setInitialVertex(1, 0, 0);
			}


			init();
			//https://math.berkeley.edu/~kmill/tools/tc.html rr; gg; bb; rbrbrbrb; grgrgr; gbgb; GRGRGR = I GR = I

			var c2 = document.createElement('div');
			document.getElementById("main").appendChild(c2);

			createSlider(c2, "nR", "RN", 1, 0, 2);
			createSlider(c2, "nG", "RG", 0, 0, 2);
			createSlider(c2, "nB", "RB", 0, 0, 2);

		</script>
		<p>
			Notice how the different cosets connects vertices, edges, and faces.
		</p>
		<p>
			For instance, see how vertex
			<a class='interactive' onmouseover='selectRow(0,0)' onmouseout='selectRow(0)'>V0</a> connects to three edges (E0,E1,E3) and three faces (F0,F1,F2). Likewise, edge
			<a class='interactive' onmouseover='selectRow(1,0)' onmouseout='selectRow(0)'>E0</a> connects two vertices (V0,V1) and two faces (F0, F1). The face
			<a class='interactive' onmouseover='selectRow(2,0)' onmouseout='selectRow(0)'>F0</a> connects four vertices (V0,V1,V2,V3) and four edges (E0,E1,E2,E4)
		</p>

		<h2>Projection</h2>

		<h2>Links</h2>
		<p>
			<a href="https://terrytao.wordpress.com/2010/07/10/cayley-graphs-and-the-geometry-of-groups/">Cayley graphs</a>
			<br/>
			<a href="https://math.berkeley.edu/~kmill/notes/todd_coxeter.html">Todd Coxeter</a>
			<br/>
			<a href="https://math.stackexchange.com/questions/259545/meaning-of-a-regular-polytope">Meaning of regular polytope</a>
			<br/>
			<a href="https://math.stackexchange.com/questions/735679/what-is-the-coxeter-diagram-for/764753">What is Coxeter diagram?</a>
			<br/>
			<a href="http://www.ams.org/notices/199706/seress.pdf2">An introduction to computational group theory</a>


		</p>

	</div>
</body>

</html>